<HTML>
<HEAD>
<TITLE>modbus EPICS device/driver support</TITLE>
</HEAD>

<BODY>
<CENTER>
    <H1>modbus</H1>
    <H1>Driver Support for Modbus Protocol under EPICS</H1>
    <H2>Release 1-1</H2>
    <H2>Mark Rivers</H2>
    <H2>April 15, 2007</H2>
</CENTER>


<HR>
<H2><CENTER>Contents</H2></CENTER>
<UL>
<LI><A HREF="#Acknowledgments">
              Acknowledgments</A>
<LI><A HREF="#Overview of Modbus">
              Overview of Modbus</A>
<LI><A HREF="#Driver architecture">
              Driver architecture</A>
<LI><A HREF="#Creating a modbus port driver">
              Creating a modbus port driver</A>
<LI><A HREF="#EPICS device support">
              EPICS device support</A>
<LI><A HREF="#Example applications">
              Example applications</A>
<LI><A HREF="#medm screens">
              medm screens</A>
<LI><A HREF="#Debug tracing">
              Debug tracing</A>
<LI><A HREF="#Differences from Triumf modtcp and plctcp package">
              Differences from Triumf modtcp and plctcp package</A>
<LI><A HREF="#Known problems">
              Known problems</A>
</UL>


<H2><CENTER><A NAME="Acknowledgments">
                     Acknowledgments</A></H2></CENTER>
The modbus package is based on the 
<A HREF=http://isacwserv.triumf.ca/epics/modtcp/TRIUMFmodtcp.html>modtcp and plctcp packages </A>
written by Rolf Keitel from Triumf.
The <B>modtcp</B> package was originally converted to Linux by Ivan So from NSLS.  
<B>modbus</B> was extensively
re-written for conversion to EPICS 3.14 and to use the EPICS asyn module.  It now contains little of the original
<B>modtcp</B> code, but retains much of the original architecture.


<H2><CENTER><A NAME="Overview of Modbus">
                     Overview of Modbus</A></H2></CENTER>

MODBUS is an application layer messaging protocol, positioned at level 7 of the OSI model,
that provides client/server communication between devices connected on different types of
buses or networks.  It is typically used for communication with I/O systems,
including Programmable Logic Controllers
(PLCs).  Modbus is supported on a variety of media, including asynchronous serial and TCP/IP over 
Ethernet.  For TCP/IP the Modbus protocol is assigned standard port 502.  
This <B>modbus</B> package supports Modbus over TCP/IP Ethernet, serial Modbus with the RTU protocol,
and serial Modbus with the ASCII protocol.
<P>
<H3>Modbus data types</H3>
Modbus provides access to the following 4 types of data:
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=4, align=center>Modbus Data Types</TH>
  </TR>
  <TR>
    <TH>Primary tables</TH>
    <TH>Object type</TH>
    <TH>Access</TH>
    <TH>Comments</TH>
  </TR>
  <TR>
    <TD>Discrete Inputs</TD>
    <TD>Single bit</TD>
    <TD>Read-Only</TD>
    <TD>This type of data can be provided by an I/O system.</TD>
  </TR>
  <TR>
    <TD>Coils</TD>
    <TD>Single bit </TD>
    <TD>Read-Write</TD>
    <TD>This type of data can be alterable by an application program.</TD>
  </TR>
  <TR>
    <TD>Input Registers</TD>
    <TD>16-bit word </TD>
    <TD>Read-Only</TD>
    <TD>This type of data can be provided by an I/O system.</TD>
  </TR>
  <TR>
    <TD>Holding Registers </TD>
    <TD>16-bit word </TD>
    <TD>Read-Write</TD>
    <TD>This type of data can be alterable by an application program.</TD>
  </TR>
  </TBODY>
</TABLE>
<P>
<H3>Modbus communications</H3>
Modbus communication consists of a <i>request message</i> sent from the <i>Modbus client</i>
to the <i>Modbus server</i>. The server replies with a <i>response message</i>.  Modbus request
messages contain:
<ul> 
  <li>An 8-bit Modbus function code that describes the type of data transfer to be performed.
  <li>A 16-bit Modbus address that describes the location in the server to read or write data from.
  <li>For write operations, the data to be transferred.
</ul>

<H3>Modbus function codes</H3>
<B>modbus</B> supports the following 8 Modbus function codes:
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>Modbus Function Codes</TH>
  </TR>
  <TR>
    <TH>Access</TH>
    <TH>Function description</TH>
    <TH>Function code</TH>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Read Coils</TD>
    <TD>1</TD>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Read Discrete Inputs</TD>
    <TD>2</TD>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Write Single Coil</TD>
    <TD>5</TD>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Write Multiple Coils</TD>
    <TD>15</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Read Input Registers</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Read Holding Registers</TD>
    <TD>3</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Write Single Register</TD>
    <TD>6</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Write Multiple Registers</TD>
    <TD>16</TD>
  </TR>
  </TBODY>
</TABLE>

<H3>Modbus addresses</H3>
Modbus addresses are specified by a 16-bit integer address.  The location of inputs and outputs
within the 16-bit address space is not defined by the Modbus protocol, it is vendor-specific.
The following table lists some of the commonly used Modbus addresses for Koyo PLCs.
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>Modbus Addresses for<BR>
    Koyo DL05/06/240/250/260/430/440/450 PLCs</TH>
  </TR>
  <TR>
    <TH>PLC Memory Type</TH>
    <TH>Modbus start address <BR>Decimal (octal)</TH>
    <TH>Function codes</TH>
  </TR>
  <TR>
    <TH colspan=3, align=center>Discrete inputs and coils</TH>
  </TR>
  <TR>
    <TD>Inputs (X)</TD>
    <TD>2048 (04000)</TD>
    <TD>2</TD>
  </TR>
  <TR>
    <TD>Special Relays (SP)</TD>
    <TD>3072 (06000)</TD>
    <TD>2</TD>
  </TR>
  <TR>
    <TD>Outputs (Y)</TD>
    <TD>2048 (04000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Control Relays (C)</TD>
    <TD>3072 (06000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Timer Contacts (T)</TD>
    <TD>6144 (014000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Counter Contacts (CT)</TD>
    <TD>6400 (014400)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Stage Status Bits (S)</TD>
    <TD>6144 (012000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TH colspan=3, align=center>Input registers and holding registers (V memory)</TH>
  </TR>
  <TR>
    <TD>Timer Current Values (TA)</TD>
    <TD>0 (00)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Counter Current Values (CTA)</TD>
    <TD>512 (01000)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Global Inputs (VGX)</TD>
    <TD>16384 (040000)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Global Outputs (VGY)</TD>
    <TD>16512 (040200)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Inputs (VX)</TD>
    <TD>16640 (040400)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Outputs (VY)</TD>
    <TD>16704 (040500)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Control Relays (VC)</TD>
    <TD>16768 (040600)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Stage Status Bits (VS)</TD>
    <TD>16896 (041000)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Timer Contacts (VT)</TD>
    <TD>16960 (041100)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Counter Contacts (VCT)</TD>
    <TD>16992 (041140)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Special Relays (VSP)</TD>
    <TD>17024 (041200)</TD>
    <TD>4</TD>
  </TR>
 </TBODY>
</TABLE>

<P>
Other PLC manufacturers will use different Modbus addresses.
<P>
Note that 16-bit Modbus addresses are commonly specified with an offset of 400001 (or 300001).
This offset is not used by the modbus driver, it uses only the 16-bit address, not the offset.
<P>
<H3>Modbus data length limitations</H3>
Modbus read operations are limited to transferring 125 16-bit words or 2000 bits.
Modbus write operations are limited to transferring 123 16-bit words or 1968 bits.
<H3>More information on Modbus</H3>
<P> 
For more information about the Modbus protocol, the official Modbus specification can be found
<A href="http://www.modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf">on the Web</A>
or in the modbus 
<A href="Modbus_Application_Protocol_V1_1b.pdf">documentation directory.</A>

<P>
The official specification for Modbus over TCP/IP can be found 
<A href="http://www.modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf">on the Web</A>
or in the modbus 
<A href="Modbus_Messaging_Implementation_Guide_V1_0b.pdf">documentation directory.</A>

<P>
The official specification for Modbus over serial can be found 
<A href="http://www.modbus.org/docs/Modbus_over_serial_line_V1_02.pdf">on the Web</A>
or in the modbus 
<A href="Modbus_over_serial_line_V1_02.pdf">documentation directory.</A>

<P>
<H2><CENTER><A NAME="Driver architecture">
                     Driver architecture</A></H2></CENTER>

<B>CAUTION:</B> modbus can provide access to all of the I/O and memory of the PLC.
In fact, it is not
even necessary to run a ladder logic program in the PLC at all.  The PLC can be used as 
a "dumb" I/O subsystem, with all of the logic residing in the EPICS IOC.  However,
if a ladder logic program <i>is</i> being run in the PLC then the EPICS access with modbus
must be designed carefully.  For example, the EPICS IOC might be allowed to <i>read</i> any of the 
PLC I/O points (X inputs, Y outputs, etc.), but <i>writes</i> could be restricted to a small
range of Control Registers, (e.g. C200-C240).  The ladder logic would monitor these
control registers, considering them to be "requests" from EPICS that should be acted
upon only if it is safe to do so.

<P>
The <B>modbus</B> module consists of an EPICS asyn port driver which functions as a Modbus client.
The modbus port driver communicates with a Modbus server using the standard asyn TCP/IP port driver (drvAsynIPPort).
The modbus port driver communicates with EPICS records using the standard asyn interfaces 
(asynUInt32Digital, asynInt32, etc.) and standard EPICS device support.  Because modbus makes extensive
use of these existing asyn facilities, the amount of code in modbus is quite small (less than 2,000 lines of
code).

<P>
Each modbus port driver is assigned a single Modbus function code and a single contiguous range of 
Modbus memory, up to 2000 bits or 125 words.  One typically creates several modbus port drivers
for a single PLC, each driver reading or writing a different set of discrete inputs, coils, 
input registers or holding registers.  For example, one might create one port driver to read 
discrete inputs X0-X37, a second to read control registers C0-C377, and a third to write control 
registers C300-C377.
<P>
The behavior of the port driver differs for
read function codes (1, 2, 3, 4) and write function codes (5, 6, 15, 16).
<P>
<H3>Modbus read functions</H3>
For read function codes the driver spawns a poller thread.  The poller thread reads the entire 
block of Modbus memory assigned to this port in a single Modbus transaction.  The values are
stored in a buffer in the driver.  The delay between
polls is set when the port driver is created, and can be changed later at run-time.  The
values are read by EPICS using the standard asyn interfaces (asynUInt32Digital, asynInt32,
etc.)  The values that are read are the last stored values from the poller thread.  This means
that EPICS read operations are <i>synchronous</i>, i.e. they do not block because no Modbus I/O
is required.  
<P>
For read functions it is possible to set the EPICS records to "I/O Intr" scanning.
If this is done then the port driver will call back device support whenever there is new data
for that input.  This improves efficiency, because such records only process when needed, they
do not need to be periodically scanned.

<P>
<H3>Modbus write functions</H3>
For write function codes the driver does not itself create a separate thread.
Rather the driver does the
Modbus I/O immediately in response to the write operations on the standard asyn interfaces.
This means that
EPICS write operations are <i>asynchronous</i>, i.e. they do block because Modbus I/O is required.
When the modbus driver is created it tells asynManager that it can block, and asynManager
creates a separate thread that executes the write operations.
<P>
Word write operations using the asynUInt32Digital interface (with a mask parameter that is not 0x0 or
0xFFFF) are done using read/modify/write operations.  This allows multiple Modbus clients to
write and read single words in the same block of Modbus memory.  
However, it <i>does not</i> guarantee correct operation
if multiple Modbus clients (or the PLC itself) can modify bits within a single word.
This is because the
Modbus server cannot perform the read/modify/write I/O as an atomic operation at the level
of the Modbus client.
<P>
For write operations it is possible to specify that a single read operation should be done when
the port driver is created.  This is normally used so that EPICS obtains the current value of an output
device when the IOC is initialized.  

<P>
<H2><CENTER><A NAME="Creating a modbus port driver">
                     Creating a modbus port driver</A></H2></CENTER>

Before modbus port drivers can be created, it is necessary to first create at least
one asyn TCP/IP
port driver to communicate with port 502 on the Modbus server on the Ethernet.  This is done
using the standard asyn command:
<pre>
drvAsynIPPortConfigure(portName, hostInfo, priority, noAutoConnect, noProcessEos)
</pre>
Documentation on this command can be found in the 
<A HREF=http://www.aps.anl.gov/epics/modules/soft/asyn/R4-7/asynDriver.html#drvAsynIPPort>
asynDriver documentation</A>.

<P>The following example creates an asyn IP port driver called "Koyo1" on port 502 at
IP address 164.54.160.158.  The default priority is used and the noAutoConnect flag is set
to 1 so that the modbus driver, rather than asynManager, will handle connection management.
The noProcessEos flag is set to 1 because Modbus data is binary, not ASCII.
<pre>
drvAsynIPPortConfigure("Koyo1","164.54.160.158:502",0,1,1)
</pre>

<P>
Once one or more asyn IP ports is created, a modbus port is created with the following command:
<pre>
drvModbusAsynConfigure(portName, 
                          tcpPortName, 
                          modbusFunction, 
                          modbusStartAddress, 
                          modbusLength,
                          dataType,
                          pollMsec, 
                          plcType);
</pre>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>drvModbusAsynConfigure command</TH>
  </TR>
  <TR>
    <TH>Parameter</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>portName</TD>
    <TD>string</TD>
    <TD>Name of the modbus port to be created.</TD>
  </TR>
  <TR>
    <TD>tcpPortName</TD>
    <TD>string</TD>
    <TD>Name of the asyn IP port previously created with drvAsynIPPortConfigure.</TD>
  </TR>
  <TR>
    <TD>modbusFunction</TD>
    <TD>int</TD>
    <TD>Modbus function code (1, 2, 3, 4, 5, 6, 15, or 16).</TD>
  </TR>
  <TR>
    <TD>modbusStartAddress</TD>
    <TD>int</TD>
    <TD>Start address for the Modbus data segment to be accessed.<BR>
       (0-65535 decimal, 0-0177777 octal).</TD>
  </TR>
 <TR>
    <TD>modbusLength</TD>
    <TD>int</TD>
    <TD>The length of the Modbus data segment to be accessed.<BR>
        This is specified in bits for Modbus functions 1, 2, 5 and 15.<BR>
        It is specified in 16-bit words for Modbus functions 3, 4, 6 and 16.<BR>
        Length limit is 2000 for functions 1 and 2, 1968 for functions 5 and 15,<BR>
        125 for functions 3 and 4, and 123 for functions 6 and 16. </TD>
  </TR>
 <TR>
    <TD>modbusDataType</TD>
    <TD>int</TD>
    <TD>Modbus data type:<BR>
        0 = binary, twos-complement format<BR>
        1 = binary, sign and magnitude format<BR>
        2 = BCD, unsigned<BR>
        3 = BCD, signed</TD>
  </TR>
<TR>
    <TD>pollMsec</TD>
    <TD>int</TD>
    <TD>Polling delay time in msec for the polling thread for read functions.<BR>
        For write functions, a non-zero value means that the Modbus data should<BR>
        be read once when the port driver is first created.</TD>
  </TR>
  <TR>
    <TD>plcType</TD>
    <TD>string</TD>
    <TD>Type of PLC (e.g. Koyo, Modicon, etc.).  <BR>
        This parameter is currently used only to print information in asynReport.<BR>
        In the future it could be used to modify the driver behavior for a specific PLC.</TD>
  </TR>
 </TBODY>
</TABLE>

<H3>Number of drvAsynIPPort drivers </H3>
Each drvAsynIPPort driver creates a separate TCP/IP socket connection to the
PLC.  It is possible to have all of the modbus port drivers share a single drvAsynIPPort 
driver.  In this case all I/O to the PLC is done over a single socket in a
 "serial" fashion.  A transaction
for one modbus driver must complete before a transaction for another modbus driver can begin.
It is also possible to create multiple drvAsynIPPort drivers (sockets) to a single PLC and, for example,
use a different drvAsynIPPort for each modbus port.  In this case I/O operations from multiple
modbus drivers can proceed in parallel, rather than serially.  This could improve performance
at the expense of more CPU load on the IOC and PLC, and more network traffic.  

<P>
It is important to 
note, however, that many PLCs will time out sockets after a few seconds of inactivity.  This
is not a problem with modbus drivers that use read function codes, because they are polling
frequently.  But modbus drivers that use write function codes may only do occasional I/O, and
hence may time out if they are the only ones communicating through a drvAsynIPPort driver.  
Thus, it is usually necessary for
modbus drivers with write function codes to use the same drvAsynIPPort driver (socket) as 
at least one modbus driver with a read function code to avoid timeouts.
<P>
The choice of how many drvAsynIPPort drivers to use per PLC will be based on empirical
performance versus resource usage considerations.  In general it is probably a good idea to
start with one drvAsynIPPort server per PLC (e.g. shared by all modbus drivers for that PLC)
and see if this results in satisfactory performance.

<H3>Number formats</H3>
It can be convenient to specify the modbusStartAddress and modbusLength in octal, rather than
decimal, because this is the convention on most PLCs.  
In the iocsh and vxWorks shells this is done by using a leading 0 on the number, i.e.
040400 is an octal number.

<H3>Modbus data types</H3>
The modbusDataType is used to tell the driver the format of the Modbus data.  The driver
uses this information to convert the number between EPICS and Modbus.  Data is transferred
to and from EPICS as epicsUInt32, epicsInt32, and epicsFloat64 numbers. 
<UL>
  <LI>Type 0 is used for binary numbers in twos-complement format.  The data
      can either be signed or unsigned.
  <LI>Type 1 is used for binary numbers in sign and magnitude format.  
      In this format bit 15 is the sign bit, and bits 0-14 are the absolute value of the 
      magnitude of the number.  
      This is one of the formats used by Koyo PLCs for numbers such as ADC conversions.
  <LI>Type 2 is used for unsigned BCD (binary coded decimal) numbers.  
      In this format a 16-bit number consists of 4 4-bit nibbles, each of which encodes
      a decimal number from 0-9. A BCD number can thus store numbers from 0 to 9999.
      Many PLCs store some numbers in BCD format.
  <LI>Type 3 is used for signed BCD (binary coded decimal) numbers.  
      In this format a 16-bit number consists of 3 4-bit nibbles, and one 3-bit nibble. 
      Bit 15 is a sign bit.  Signed BCD numbers can hold values
      from -7999 to +7999.
      This is one of the formats used by Koyo PLCs for numbers such as ADC conversions.
</UL>
Note that if
it is desired to transmit BCD numbers untranslated to EPICS over the asynInt32 interface, 
then data type 0 should be used, because no translation is done in this case.
<P>
Other data types can be added in the future as needed.

<P>
<H2><CENTER><A NAME="EPICS device support">
                     EPICS device support</A></H2></CENTER>

modbus implements the following standard asyn interfaces:
<UL>
  <LI>asynUInt32Digital
  <LI>asynInt32
  <LI>asynInt32Array
  <LI>asynFloat64
  <LI>asynCommon
  <LI>asynDrvUser
</UL>

Because it implements these standard interfaces, EPICS device support is done entirely
with the generic EPICS device support provided with asyn itself.  There is no special
device support provided as part of modbus.

<P>
It is necessary to use asyn R4-8 or later, because some minor enhancements were made
to asyn to support the features required by modbus.

<P>
The following tables document the asyn interfaces used by the EPICS device support.

<P>
The <B>drvUser</B> parameter is used by the driver to determine what command is being sent
from device support.  The default is MODBUS_DATA, which is thus optional in the
link specification in device support.

<P>
The <B>offset</B> parameter is used to specify the location of the data for a record
relative to the starting Modbus address for that driver.  This <B>offset</B> is specified in
bits for drivers using Modbus functions 1, 2, 5, and 15 
that control discrete inputs or coils.  For example, if the Modbus function is 2 and the 
Modbus starting address is 04000, 
then <B>offset=2</B> refers to address 04002.  For a Koyo PLC the X inputs are at this Modbus
starting address for Modbus function 2, so <B>offset=2</B> is input X2.  

<P>
The <B>offset</B> is specified in
words for drivers using Modbus functions 3, 4, 6 and 16 that address input registers or holding
registers.  For example, if the Modbus function is set to 6 and the Modbus address is 
040600 then <B>offset=2</B> refers to address 040602.   For a Koyo PLC the C control relays
are accessed as 16-bit words at this Modbus starting address for Modbus function 6.
<B>offset=2</B> will thus write to the third 16 bit-word, which is coils C40-C57.

<H3>asynUInt32Digital</H3>
asynUInt32Digital device support is selected with 
<pre>
field(DTYP,"asynUInt32Digital")
field(INP,"@asynMask(portName,offset,mask,timeout)drvUser")</pre>
</pre>

<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynUInt32Digital Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bi, mbbi, mbbiDirect, longin</TD>
    <TD>value = (Modbus data & mask)<BR>
       (normally mask=1)</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bi, mbbi, mbbiDirect, longin</TD>
    <TD>value = (Modbus data & mask)<BR>
       (mask selects bits of interest)</TD>
  </TR>
  <TR>
    <TD>5</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bo, mbbo, mbboDirect, longout</TD>
    <TD>Modbus write (value & mask)<BR>
       (normally mask=1)</TD>
  </TR>
  <TR>
    <TD>6</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bo, mbbo, mbboDirect, longout</TD>
    <TD>If mask==0 or mask==0xFFFF does Modbus write (value)<BR>
        Else does read/modify/write:<BR>
        Sets bits that are set in value and set in mask,<BR>
        Clears bits that are clear in value and set in mask</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>ENABLE_HISTOGRAM</TD>
    <TD>bi, mbbi, mbbiDirect, longin</TD>
    <TD>Returns 0/1 if I/O time histogramming is disabled/enabled in driver<BR>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>ENABLE_HISTOGRAM</TD>
    <TD>bo, mbbo, mbboDirect, longout</TD>
    <TD>If value = 0/1 then disable/enable I/O time histogramming in driver<BR>
  </TR>
 </TBODY>
</TABLE>
  

<H3>asynInt32</H3>
asynInt32 device support is selected with 
<pre>
field(DTYP,"asynInt32")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
</pre>
or
<pre>
field(INP,"@asynMask(portName,offset,nbits,timeout)drvUser")</pre>
</pre>
The asynMask syntax is used for analog I/O devices, in order to specify the
number of bits in the device.  This is required for Modbus because the driver
only knows that it is returning a 16-bit register, but not the actual number of
bits in the device, and hence cannot return meaningful data with asynInt32->getBounds().
<P>
nbits>0 for a unipolar device.  For example, nbits=12 means unipolar 12-bit device,
with a range of 0 to 4095.
nbits<0 for a bipolar device.  For example, nbits=-12 means bipolar 12-bit device, 
with a range of -2048 to 2047)
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynInt32 Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>value = (epicsInt32)Modbus data</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>value = (epicsInt32)Modbus data</TD>
  </TR>
  <TR>
    <TD>5</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao, mbbo, longout</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>6</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao, mbbo, longout</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>READ_OK</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of successful read operations on this asyn port</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>WRITE_OK</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of successful write operations on this asyn port</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>IO_ERRORS</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of I/O errors on this asyn port</TD>
  </TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>LAST_IO_TIME</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of milliseconds for last I/O operation</TD>
  </TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>MAX_IO_TIME</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns maximum number of milliseconds for I/O operations</TD>
  </TR>
 </TBODY>
</TABLE>
  
<H3>asynFloat64</H3>
asynFloat64 device support is selected with 
<pre>
field(DTYP,"asynFloat64")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynFloat64 Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai</TD>
    <TD>value = (epicsFloat64)Modbus data</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai</TD>
    <TD>value = (epicsFloat64)Modbus data</TD>
  </TR>
  <TR>
    <TD>5</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>6</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>POLL_DELAY</TD>
    <TD>ai, ao</TD>
    <TD>Read or write the delay time in seconds between polls for the read poller thread.</TD>
  </TR>
 </TBODY>
</TABLE>
  
<H3>asynInt32Array</H3>
asynInt32Array device support is selected with 
<pre>
field(DTYP,"asynInt32ArrayWfIn")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
</pre>
or
<pre>
field(DTYP,"asynInt32ArrayWfOut")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
</pre>
asynInt32Array device support is used to read or write arrays of up to 2000 coil values
or up to 125 16-bit registers.  It is also used to read the histogram array of I/O times
when histogramming is enabled.
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynInt32Array Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>NA</TD>
    <TD>Array of bits</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (input)</TD>
    <TD>value = (epicsInt32)Modbus data[]</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>NA</TD>
    <TD>Array of 16-bit words</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (input)</TD>
    <TD>value = (epicsInt32)Modbus data[]</TD>
  </TR>
  <TR>
    <TD>15</TD>
    <TD>NA</TD>
    <TD>Array of bits</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (output)</TD>
    <TD>Modbus write (epicsInt16)value[]</TD>
  </TR>
  <TR>
    <TD>16</TD>
    <TD>NA</TD>
    <TD>Array of 16-bit words</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (output)</TD>
    <TD>Modbus write (epicsInt16)value[]</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>READ_HISTOGRAM</TD>
    <TD>waveform (input)</TD>
    <TD>Returns a histogram array of the I/O times in milliseconds since
        histogramming was last enabled.</TD>
  </TR>
 </TBODY>
</TABLE>
<P>
<H3>Template files</H3>
<P> 
modbus provides example template files in the modbusApp/Db directory.  
These include:
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>Template Files</TH>
  </TR>
  <TR>
    <TH>Files</TH>
    <TH>Description</TH>
    <TH>Macro arguments</TH>
  </TR>
  <TR>
  <TR>
    <TD>bi_bit.template</TD>
    <TD>asynUInt32Digital support for bi record with discrete inputs or coils. Mask=1.</TD>
    <TD>P, R, PORT, OFFSET, ZNAM, ONAM, ZSV, OSV, SCAN</TD>
  </TR>
  <TR>
    <TD>bi_word.template</TD>
    <TD>asynUInt32Digital support for bi record with register inputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK, ZNAM, ONAM, ZSV, OSV, SCAN</TD>
  </TR>
  <TR>
    <TD>mbbiDirect.template</TD>
    <TD>asynUInt32Digital support for mbbiDirect record with register inputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK, SCAN</TD>
  </TR>
  <TR>
    <TD>longin.template</TD>
    <TD>asynUInt32Digital support for longin record with register inputs. Mask=0xFFFF.</TD>
    <TD>P, R, PORT, OFFSET, SCAN</TD>
  </TR>
  <TR>
    <TD>intarray_in.template</TD>
    <TD>asynInt32Array support for waveform record with discrete, coil, or register inputs.</TD>
    <TD>P, R, PORT, NELM, SCAN</TD>
  </TR>
  <TR>
    <TD>bo_bit.template</TD>
    <TD>asynUInt32Digital support for bo record with coil outputs. Mask=1.</TD>
    <TD>P, R, PORT, OFFSET, ZNAM, ONAM</TD>
  </TR>
  <TR>
    <TD>bo_word.template</TD>
    <TD>asynUInt32Digital support for bo record with register outputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK, ZNAM, ONAM</TD>
  </TR>
  <TR>
    <TD>mbboDirect.template</TD>
    <TD>asynUInt32Digital support for mbboDirect record with register outputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK</TD>
  <TR>
    <TD>longout.template</TD>
    <TD>asynUInt32Digital support for longout record with register outputs. Mask=0xFFFF.</TD>
    <TD>P, R, PORT, OFFSET</TD>
  </TR>
  <TR>
    <TD>intarray_out.template</TD>
    <TD>asynInt32Array support for waveform record with discrete, coil, or register outputs.</TD>
    <TD>P, R, PORT, NELM</TD>
  </TR>
  </TR>
    <TD>ai.template</TD>
    <TD>asynInt32 support for ai record with LINEAR conversion</TD>
    <TD>P, R, PORT, OFFSET, BITS, EGUL, EGUF, PREC, SCAN</TD>
  </TR>
  <TR>
    <TD>ai_average.template</TD>
    <TD>asynInt32Average support for ai record with LINEAR conversion.  This support
        gets callbacks each time the poll thread reads the analog input, and averages
        readings until the record is processed.</TD>
    <TD>P, R, PORT, OFFSET, BITS, EGUL, EGUF, PREC, SCAN</TD>
  </TR>
  <TR>
    <TD>asynRecord.template</TD>
    <TD>Support for asyn record.  Useful for controlling trace printing, and for debugging.</TD>
    <TD>P, R, PORT, ADDR, TMOD, IFACE</TD>
  </TR>
  <TR>
    <TD>poll_delay.template</TD>
    <TD>Support for ao record to control the delay time for the poller thread.</TD>
    <TD>P, R, PORT</TD>
  </TR>
  <TR>
    <TD>statistics.template</TD>
    <TD>Support for bo, longin and waveform records to read I/O statistics for the port.
    <TD>P, R, PORT, SCAN</TD>
  </TR>
 </TBODY>
</TABLE>
<P>
The following table explains the macro parameters used in the preceeding table.
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=2, align=center>Macro Parameters</TH>
  </TR>
  <TR>
    <TH>Macro</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>P</TD>
    <TD>Prefix for record name.  Complete record name is $(P)$(R).</TD>
  </TR>
  <TR>
    <TD>R</TD>
    <TD>Record name.  Complete record name is $(P)$(R).</TD>
  </TR>
  <TR>
    <TD>PORT</TD>
    <TD>Port name for modbus asyn port.</TD>
  </TR>
  <TR>
    <TD>OFFSET</TD>
    <TD>Offset for Modbus data relative to start address for this port.</TD>
  </TR>
  <TR>
    <TD>MASK</TD>
    <TD>Bit mask used to select data for this record.</TD>
  </TR>
  <TR>
    <TD>ZNAM</TD>
    <TD>String for 0 value for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>ONAM</TD>
    <TD>String for 1 value for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>ZSV</TD>
    <TD>0 severity for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>OSV</TD>
    <TD>1 severity for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>BITS</TD>
    <TD>Number of bits for analog I/O devices. >0=unipolar, <0=bipolar.</TD>
  </TR>
  <TR>
    <TD>EGUL</TD>
    <TD>Engineering value for lower limit of analog device.</TD>
  </TR>
  <TR>
    <TD>EGUF</TD>
    <TD>Engineering value for upper limit of analog device.</TD>
  </TR>
  <TR>
    <TD>PREC</TD>
    <TD>Number of digits of precision for ai/ao records.</TD>
  </TR>
  <TR>
    <TD>NELM</TD>
    <TD>Number of elements in waveform records.</TD>
  </TR>
  <TR>
    <TD>ADDR</TD>
    <TD>Address for asyn record, same as OFFSET above.</TD>
  </TR>
  <TR>
    <TD>TMOD</TD>
    <TD>Transfer mode for asyn record.</TD>
  </TR>
  <TR>
    <TD>IFACE</TD>
    <TD>asyn interface for asyn record.</TD>
  </TR>
  <TR>
    <TD>SCAN</TD>
    <TD>Scan rate for record (e.g. "1 second", "I/O Intr", etc.).</TD>
  </TR>
 </TBODY>
</TABLE>

<H2><CENTER><A NAME="Example Applications">
                     Example Applications</A></H2></CENTER>
<P>
modbus builds an example application called modbusApp.  This application can be run
to control any number of Modbus PLCs.
<P>
In the iocBoot/iocTest directory there are several startup scripts for EPICS IOCs.  These
are designed to test most of the features of the modbus driver on Koyo PLCs, such as the
DL series from Automation Direct.
<P>
<UL>
  <LI>Koyo1.cmd creates modbus port drivers to read the X inputs,
      write to the Y outputs, and read and write from the C control registers.
      Each of these sets of inputs and outputs is accessed both as coils and as registers (V memory).
      bi/bo, mbbiDirect/mbboDirect, and waveform records are loaded to read and write
      using these drivers.
  <LI>Koyo2.cmd creates modbus port drivers to read the X inputs,
      write to the Y outputs, and read and write from the C control registers.
      Only coil access is used.  This example also reads a 4-channel 13-bit bipolar A/D
      converter.  This has been tested using both signed-BCD and sign plus magnitude binary
      formats.  Note that a ladder logic program must be loaded that does the appropriate
      conversion of the A/D values into V memory.
  <LI>st.cmd is a simple example startup script to be run on non-vxWorks IOCs.  It just loads
      Koyo1.cmd and Koyo2.cmd.  It is invoked using a command like:
      <pre>
      ../../bin/linux-x86/modbusApp st.cmd
      </pre>
      One can also load Koyo1.cmd or Koyo2.cmd separately as in:
      <pre>
      ../../bin/linux-x86/modbusApp Koyo1.cmd
      </pre>     
  <LI>st.cmd.vxWorks is a simple example startup script to be run on vxWorks IOCs.  It just loads
      Koyo1.cmd and Koyo2.cmd.
</UL>
<P>
The following is the beginning of Koyo1.cmd.
<pre>
# Koyo1.cmd
< envPaths

dbLoadDatabase("../../dbd/modbus.dbd")
modbus_registerRecordDeviceDriver(pdbbase)

#drvAsynIPPortConfigure(const char *portName, const char *hostInfo,
#                           unsigned int priority, int noAutoConnect,
#                           int noProcessEos);
drvAsynIPPortConfigure("Koyo1","164.54.160.158:502",0,1,1)
#drvAsynIPPortConfigure("Koyo1","164.54.160.201:502",0,0,1)


# NOTE: We use octal numbers for the start address and length (leading zeros)
#       to be consistent with the PLC nomenclature.  This is optional, decimal
#       numbers (no leading zero) or hex numbers can also be used.

# The DL205 has bit access to the Xn inputs at Modbus offset 4000 (octal)
# Read 32 bits (X0-X37).  Function code=2.
drvModbusAsynConfigure("K1_Xn_Bit",      "Koyo1", 2,  04000, 040,    0,  100, "Koyo")

# The DL205 has word access to the Xn inputs at Modbus offset 40400 (octal)
# Read 8 words (128 bits).  Function code=3.
drvModbusAsynConfigure("K1_Xn_Word",     "Koyo1", 3, 040400, 010,    0,  100, "Koyo")

# The DL205 has bit access to the Yn outputs at Modbus offset 4000 (octal)
# Read 32 bits (Y0-Y37).  Function code=1.
drvModbusAsynConfigure("K1_Yn_In_Bit",   "Koyo1", 1,  04000, 040,    0,  100, "Koyo")

# The DL205 has bit access to the Yn outputs at Modbus offset 4000 (octal)
# Write 32 bits (Y0-Y37).  Function code=5.
drvModbusAsynConfigure("K1_Yn_Out_Bit",  "Koyo1", 5,  04000, 040,    0,  1, "Koyo")

# The DL205 has word access to the Yn outputs at Modbus offset 40500 (octal)
# Read 8 words (128 bits).  Function code=3.
drvModbusAsynConfigure("K1_Yn_In_Word",  "Koyo1", 3, 040500, 010,    0,  100, "Koyo")

# Write 8 words (128 bits).  Function code=6.
drvModbusAsynConfigure("K1_Yn_Out_Word", "Koyo1", 6, 040500, 010,    0,  100, "Koyo")

# The DL205 has bit access to the Cn bits at Modbus offset 6000 (octal)
# Access 256 bits (C0-C377) as inputs.  Function code=1.
drvModbusAsynConfigure("K1_Cn_In_Bit",   "Koyo1", 1,  06000, 0400,   0,  100, "Koyo")

# Access the same 256 bits (C0-C377) as outputs.  Function code=5.
drvModbusAsynConfigure("K1_Cn_Out_Bit",  "Koyo1", 5,  06000, 0400,   0,  1,  "Koyo")

# Access the same 256 bits (C0-C377) as array outputs.  Function code=15.
drvModbusAsynConfigure("K1_Cn_Out_Bit_Array",  "Koyo1", 15,  06000, 0400,   0,   1, "Koyo")

# The DL205 has word access to the Cn bits at Modbus offset 40600 (octal)
# We use the first 16 words (C0-C377) as inputs (256 bits).  Function code=3.
drvModbusAsynConfigure("K1_Cn_In_Word",  "Koyo1", 3, 040600, 020,    0,  100, "Koyo")

# We access the same 16 words (C0-C377) as outputs (256 bits). Function code=6.
drvModbusAsynConfigure("K1_Cn_Out_Word", "Koyo1", 6, 040600, 020,    0,  1,  "Koyo")

# We access the same 16 words (C0-C377) as array outputs (256 bits). Function code=16.
drvModbusAsynConfigure("K1_Cn_Out_Word_Array", "Koyo1", 16, 040600, 020,    0,   1, "Koyo")
</pre>

Note that this example is designed for testing and demonstration purposes, not as a realistic
example of how modbus would normally be used.  For example, it loads 
6 drivers to access the C control relays using function codes 1 (read coils), 3 (read holding
registers), 5 (write single coil), 6 (write single holding register), 15 (write multiple coils),
and 16 (write multiple holding registers).  This allows for testing of all function codes
and record types, including waveforms.  In practice one would normally only load at most 2
drivers for the C control relays, for example function code 1 (read coils), and function
code 5 (write single coil).

<H2><CENTER><A NAME="medm screens">
                     medm screens</A></H2></CENTER>
<P>
modbus provides example medm .adl files in the modtcpApp/op/adl directory.  
The following are screen shots of these screens from an IOC controlling a
Koyo DL205 PLC.
<P>
<p align="center"><img border="0" src="Koyo1.png"></p>
<p align="center"><B>Koyo1.adl.  
Top level medm screen for the Koyo1 example application.</B></P>
<P>
<p align="center"><img border="0" src="K1_Xn_Bit.png"></p>
<p align="center"><B>Koyo_8inputs.adl.  
Inputs X0-X7 read as discrete inputs (function code 1).</B></p>
<P>
<p align="center"><img border="0" src="K1_Yn_Out_Word.png"></p>
<p align="center"><B>Koyo_8outputs.adl.  
Outputs Y0-Y7 written using register access (function code 6).</B></p>
<P>
<p align="center"><img border="0" src="K1_C20n_Out_Bit.png"></p>
<p align="center"><B>Koyo_8outputs.adl. 
Outputs C200-C207 written using bit access (function code 5).</B></p>
<P>
<p align="center"><img border="0" src="K1_C20n_In_Word.png"></p>
<p align="center"><B>Koyo_8inputs.adl.  
Inputs C200-C207 read as register inputs (function code 6).</B></p>
<P>
<p align="center"><img border="0" src="K1_Cn_In_Bit_Array.png"></p>
<p align="center"><B>modbusArray.adl.  
Inputs C0-C377 read using a waveform record and coil access (function code 1).</B></p>
<P>
<p align="center"><img border="0" src="K1_Cn_In_Word_Array.png"></p>
<p align="center"><B>modbusArray.adl.  
Inputs C0-C377 read using a waveform record and register access (function
code 3).</B></p>
<P>
<p align="center"><img border="0" src="K1_Xn_Bit_Statistics.png"></p>
<p align="center"><B>modbusStatistics.adl.  
I/O statistics for the Modbus driver that is reading inputs
X0-X37 using register access (function code 3).  The histogram is the number of events
versus TCP/IP write/read cycle time in msec.</B></p>
<P>
<p align="center"><img border="0" src="Koyo2.png"></p>
<p align="center"><B>Koyo2.adl.  
Top level medm screen for the Koyo2 example application.</B></p>
<P>
<p align="center"><img border="0" src="K2_ADCs.png"></p>
<p align="center"><B>Koyo_4ADC.adl.  
4 ADC inputs from a 13-bit bipolar ADC.</B></p>


<H2><CENTER><A NAME="Debug tracing">
                     Debug tracing</A></H2></CENTER>
                     
One can obtain diagnostic output for a modbus port driver using 
the "dbior" or "asynPrint" commands
at the iocsh or vxWorks shell.
"asynReport" with no arguments will print a brief report for all asyn drivers, 
including the drvAsynIPPort driver that modbus
drivers are connected to, and for all modbus port drivers.  
For example, a partial output for the Koyo1 application is:
<pre>
epics> asynReport
Koyo1 multiDevice:No canBlock:Yes autoConnect:No
Port 164.54.160.158:502: Connected
K1_Xn_Bit multiDevice:Yes canBlock:No autoConnect:Yes
    addr 0 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 1 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 2 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 3 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 4 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 5 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 6 autoConnect Yes enabled Yes connected Yes exceptionActive No
    addr 7 autoConnect Yes enabled Yes connected Yes exceptionActive No
modbus port: K1_Xn_Bit
K1_Xn_Word multiDevice:Yes canBlock:No autoConnect:Yes
    addr 0 autoConnect Yes enabled Yes connected Yes exceptionActive No
</pre>
To obtain more
detailed information, one can request information for a specific modbus port driver, and
output level >0 as follows:
<pre>
epics> asynReport 5, "K1_Xn_Word"
K1_Xn_Word multiDevice:Yes canBlock:No autoConnect:Yes
    enabled:Yes connected:Yes numberConnects 1
    nDevices 1 nQueued 0 blocked:No
    asynManagerLock:No synchronousLock:No
    exceptionActive:No exceptionUsers 0 exceptionNotifys 0
    interfaceList
        asynCommon pinterface 0x4001d180 drvPvt 0x8094f78
        asynDrvUser pinterface 0x4001d10c drvPvt 0x8094f78
        asynUInt32Digital pinterface 0x4001d118 drvPvt 0x8094f78
        asynInt32 pinterface 0x4001d134 drvPvt 0x8094f78
        asynFloat64 pinterface 0x4001d148 drvPvt 0x8094f78
        asynInt32Array pinterface 0x4001d158 drvPvt 0x8094f78
    addr 0 autoConnect Yes enabled Yes connected Yes exceptionActive No
    exceptionActive No exceptionUsers 1 exceptionNotifys 0
    blocked No
modbus port: K1_Xn_Word
    asyn TCP server:    Koyo1
    modbusFunction:     3
    modbusStartAddress: 040400
    modbusLength:       010
    plcType:            Koyo
    I/O errors:         0
    Read OK:            5728
    Write OK:           0
    pollDelay:          0.100000
    Time for last I/O   3 msec
    Max. I/O time:      12 msec
</pre>
<P>
To obtain run-time debugging output for a driver use the asynSetTraceMask 
and asynSetTraceIOMask commands.  For example the following commands will show
all I/O to and from the PLC from the underlying drvAsynIPPort driver:
<pre>
epics> asynSetTraceIOMask "Koyo1",0,4   # Enable traceIOHex
epics> asynSetTraceMask "Koyo1",0,9     # Enable traceError and traceIODriver
epics> 
2007/04/12 17:27:45.384 164.54.160.158:502 write 12

00 01 00 00 00 07 ff 02 08 00 00 20 
2007/04/12 17:27:45.390 164.54.160.158:502 read 13

00 01 00 00 00 07 ff 02 04 00 00 00 00 
2007/04/12 17:27:45.424 164.54.160.158:502 write 12

00 01 00 00 00 07 ff 03 41 00 00 08 
2007/04/12 17:27:45.432 164.54.160.158:502 read 25

00 01 00 00 00 13 ff 03 10 00 00 00 00 00 00 00 00 00 00 00 
00 00 00 00 00 
...
epics> asynSetTraceMask "Koyo1",0,1    # Turn off traceIODriver
</pre>

The following command shows the I/O from a specific modbus port driver:
<pre>
epics> asynSetTraceIOMask "K1_Yn_In_Word",0,4   # Enable traceIOHex
epics> asynSetTraceMask "K1_Yn_In_Word",0,9     # Enable traceError and traceIODriver
epics> 
2007/04/12 17:32:31.548 drvModbusAsyn::doModbusIO port K1_Yn_In_Word READ_REGISTERS
09 00 00 00 00 00 00 00 
2007/04/12 17:32:31.656 drvModbusAsyn::doModbusIO port K1_Yn_In_Word READ_REGISTERS
09 00 00 00 00 00 00 00 
2007/04/12 17:32:31.770 drvModbusAsyn::doModbusIO port K1_Yn_In_Word READ_REGISTERS
09 00 00 00 00 00 00 00 
2007/04/12 17:32:31.878 drvModbusAsyn::doModbusIO port K1_Yn_In_Word READ_REGISTERS
09 00 00 00 00 00 00 00 
2007/04/12 17:32:31.987 drvModbusAsyn::doModbusIO port K1_Yn_In_Word READ_REGISTERS
09 00 00 00 00 00 00 00 
epics> asynSetTraceMask "K1_Yn_In_Word",0,1     # Disable traceIODriver
</pre>

One can also load an EPICS asyn record on a modbus port, and then use EPICS channel access
to turn debugging output on and off.  The following medm screen shows how to turn on I/O tracing
using this method.

<p align="center"><img border="0" src="K1_Yn_In_Word.png"></p> 
<p align="center"><B>asynRecord.adl.  
Using the asynRecord to turn on traceIODriver and traceIOHex for debugging.</B></p>

The asyn record can also be used to perform actual I/O to the PLC.  For example the following
screen shots shows the asyn record being used to control output Y1 on a PLC.  Note that the ADDR
field is set to 1 (to select Y1) and the data set to 1 (to turn on the output).  Each time the
asyn record is processed the value will be sent to the PLC.
<P>
<p align="center"><img border="0" src="K1_Yn_Out_Bit_Asyn.png"></p> 
<p align="center"><B>asynRecord.adl. 
Using the asynRecord to perform actual I/O to a PLC.  Note that Address (ADDR)=1.</B> </p>

<p align="center"><img border="0" src="K1_Yn_Out_Bit_AsynRegister.png"></p> 
<p align="center"><B>asynRegister.adl. 
Using the asynRecord to perform actual I/O to a PLC.  Note that Interface
(IFACE)=asynUInt32Digital, Transfer (TMOD)=Write, and 
Output (UI32OUT)=1.  This value will be written to the Y1 output when the record is
processed.</B> </p>

<H2><CENTER><A NAME="Differences from Triumf modtcp and plctcp package">
                     Differences from Triumf modtcp and plctcp package</A></H2></CENTER>

The following are the main enhancements of modbus compared to the modtcp and plctcp
packages from Triumf:
<UL>
  <LI>modbus supports most Modbus function codes,
      including 1, 2, 5, and 15 for reading and writing coils (single bits)
      and 3, 4, 6, and 16 for reading and writing registers. 
      modtcp supports only Modbus functions 3 (read holding register) and 
      6 (write holding register).  
  <LI>modbus supports pseudo-interrupt mode on inputs.  
      The poller thread calls device support when there is a new value, 
      so the EPICS records can have SCAN=I/O Intr and 
      do not need to periodically read the inputs. This is more efficient.
  <LI>modbus supports array operations on reads and writes using waveform records.
  <LI>modbus uses asyn for underlying TCP/IP connections.  
      This reduces the amount of code, and has good debugging and connection management.
  <LI>modbus uses standard asyn interfaces and asyn device support.  
      This reduces the amount of code significantly.
  <LI>modbus should run on all EPICS platforms.  It has been tested on
      linux-x86, vxWorks, win32-x86 (native Windows with VC++ compiler), and
      cygwin-x86 (Windows with gcc compiler and Cygwin library).  
      The only thing that may be architecture-specific is the
      structure packing in modbus.h.  The "#pragma pack(1)" directive used there
      is supported on gnu and Microsoft compilers.  modtcp only works on Linux and
      vxWorks. 
  <LI>modbus provides EPICS PVs for PLC status and statistics.
</UL>
<P>
The following are some drawbacks of modbus compared to the modtcp and plctcp
packages from Triumf:
<UL>
  <LI>modbus only works on EPICS 3.14, not on 3.13.
  <LI>There is no Siemens PLC support.  It should be a separate driver, 
      using drvModbusAsyn.c as a model.  Most code in modbus is Modbus
      specific, so it is cleaner to write a separate, but similar driver for other
      protocols. <BR>
  <LI>modbus has one thread per asyn port, which is a group of Modbus registers or coils.  
      This is more threads than modtcp, which had only 1 thread per PLC. 
      There is an advantage in the modbus design, because each can poll at a different rate, 
      can have different Modbus function code, and a different data type.  
      It also allows much finer granularity in debugging output.  But it will
      lead to somewhat increased resource usage compared to the modtcp design.
</Ul>

<H2><CENTER><A NAME="Known problems">
                     Known problems</A></H2></CENTER>
                     
<UL>
  <LI>It should be
      possible to use the AutoConnect feature when creating the drvAsynIPPort driver.  However,
      there seems to be a problem with the automatic connection management in asyn.  For now 
      connection management is done by the modbus driver itself, so the noAutoConnect flag
      should be set to 1 in drvAsynIPPortConfigure.  With this setting the modbus
      driver will automatically reconnect if a PLC is disconnected from the network or rebooted.
      However, it is necessary for the PLC to be available when the IOC first boots
      or the "read once" values for drivers with Modbus write functions 
      will not be read by EPICS.

  <LI>The asyn interface APIs for callbacks need to be changed to add status, 
      allowing I/O Intr records to report communication errors to EPICS.
</UL>


</BODY>
</HTML>
