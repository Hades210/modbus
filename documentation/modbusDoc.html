<HTML>
<HEAD>
<TITLE>modbusTCP EPICS device/driver support</TITLE>
</HEAD>

<BODY>
<CENTER>
    <H1>Driver Support for Modbus/TCP Protocol under EPICS</H1>
    <H2>Mark Rivers</H2>
    <H2>March 22, 2007</H2>
</CENTER>


<HR>
<H2><CENTER>Contents</H2></CENTER>
<UL>
<LI><A HREF="#Acknowledgments">
              Acknowledgments</A>
<LI><A HREF="#Overview of Modbus">
              Overview of Modbus</A>
<LI><A HREF="#Driver architecture">
              Driver architecture</A>
<LI><A HREF="#Creating a modbusTCP port driver">
              Creating a modbusTCP port driver</A>
<LI><A HREF="#EPICS device support">
              EPICS device support</A>
<LI><A HREF="#Example applications">
              Example applications</A>
<LI><A HREF="#Debug tracing">
              Debug tracing</A>
<LI><A HREF="#medm screens">
              medm screens</A>
<LI><A HREF="#Differences from Triumf modtcp and plctcp package">
              Differences from Triumf modtcp and plctcp package</A>
<LI><A HREF="#Known problems">
              Known problems</A>
</UL>

<H2><CENTER><A NAME="Acknowledgments">
                     Acknowledgments</A></H2></CENTER>
The modbusTcp package is based on the 
<A HREF=http://isacwserv.triumf.ca/epics/modtcp/TRIUMFmodtcp.html>modtcp and plctcp packages </A>
written by Rolf Keitel from Triumf.
The <b>modtcp</b> package was originally converted to Linux by Ivan So from NSLS.  
<b>modbusTCP</b> was extensively
re-written for conversion to EPICS 3.14 and to use the EPICS asyn module.  It now contains little of the original
<b>modtcp</b> code, but retains much of the original architecture.

<H2><CENTER><A NAME="Overview of Modbus">
                     Overview of Modbus</A></H2></CENTER>

MODBUS is an application layer messaging protocol, positioned at level 7 of the OSI model,
that provides client/server communication between devices connected on different types of
buses or networks.  It is typically used for communication with I/O systems,
including Programmable Logic Controllers
(PLCs).  Modbus is supported on a variety of media, including asynchronous serial and TCP/IP over 
Ethernet.  For TCP/IP the Modbus protocol is assigned standard port 502.  This <b>modbusTCP</b> package only supports Modbus over TCP/IP Ethernet.
<P>
<H3>Modbus data types</H3>
Modbus provides access to the following 4 types of data:
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=4, align=center>Modbus Data Types</TH>
  </TR>
  <TR>
    <TH>Primary tables</TH>
    <TH>Object type</TH>
    <TH>Access</TH>
    <TH>Comments</TH>
  </TR>
  <TR>
    <TD>Discrete Inputs</TD>
    <TD>Single bit</TD>
    <TD>Read-Only</TD>
    <TD>This type of data can be provided by an I/O system.</TD>
  </TR>
  <TR>
    <TD>Coils</TD>
    <TD>Single bit </TD>
    <TD>Read-Write</TD>
    <TD>This type of data can be alterable by an application program.</TD>
  </TR>
  <TR>
    <TD>Input Registers</TD>
    <TD>16-bit word </TD>
    <TD>Read-Only</TD>
    <TD>This type of data can be provided by an I/O system.</TD>
  </TR>
  <TR>
    <TD>Holding Registers </TD>
    <TD>16-bit word </TD>
    <TD>Read-Write</TD>
    <TD>This type of data can be alterable by an application program.</TD>
  </TR>
  </TBODY>
</TABLE>
<P>
<H3>Modbus communications</H3>
Modbus communication consists of a <i>request message</i> sent from the <i>Modbus client</i>
to the <i>Modbus server</i>. The server replies with a <i>response message</i>.  Modbus request
messages contain:
<ul> 
  <li>An 8-bit Modbus function code that describes the type of data transfer to be performed.
  <li>A 16-bit Modbus address that describes the location in the server to read or write data from.
  <li>For write operations, the data to be transfered.
</ul>

<H3>Modbus function codes</H3>
<b>modbusTCP</b> supports the following 8 Modbus function codes:
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>Modbus Function Codes</TH>
  </TR>
  <TR>
    <TH>Access</TH>
    <TH>Function description</TH>
    <TH>Function code</TH>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Read Coils</TD>
    <TD>1</TD>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Read Discrete Inputs</TD>
    <TD>2</TD>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Write Single Coil</TD>
    <TD>5</TD>
  </TR>
  <TR>
    <TD>Bit access</TD>
    <TD>Write Multiple Coils</TD>
    <TD>15</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Read Input Register</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Read Holding Registers</TD>
    <TD>3</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Write Single Register</TD>
    <TD>6</TD>
  </TR>
  <TR>
    <TD>16-bit word access</TD>
    <TD>Write Multiple Registers</TD>
    <TD>16</TD>
  </TR>
  </TBODY>
</TABLE>

<H3>Modbus addresses</H3>
Modbus addresses are specified by a 16-bit integer address.  The location of inputs and outputs
within the 16-bit address space is not defined by the Modbus protocol, it is vendor-specific.
The following table lists some of the commonly used Modbus addresses for Koyo PLCs.
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>Modbus Addresses for<BR>
    Koyo DL05/06/240/250/260/430/440/450 PLCs</TH>
  </TR>
  <TR>
    <TH>PLC Memory Type</TH>
    <TH>Modbus start address <BR>Decimal (octal)</TH>
    <TH>Function codes</TH>
  </TR>
  <TR>
    <TH colspan=3, align=center>Discrete inputs and coils</TH>
  </TR>
  <TR>
    <TD>Inputs (X)</TD>
    <TD>2048 (04000)</TD>
    <TD>2</TD>
  </TR>
  <TR>
    <TD>Special Relays (SP)</TD>
    <TD>3072 (06000)</TD>
    <TD>2</TD>
  </TR>
  <TR>
    <TD>Outputs (Y)</TD>
    <TD>2048 (04000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Control Relays</TD>
    <TD>3072 (06000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Timer Contacts (T)</TD>
    <TD>6144 (014000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Counter Contacts (CT)</TD>
    <TD>6400 (014400)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TD>Stage Status Bits (S)</TD>
    <TD>6144 (012000)</TD>
    <TD>1, 5, 15</TD>
  </TR>
  <TR>
    <TH colspan=3, align=center>Input registers and holding registers (V memory)</TH>
  </TR>
  <TR>
    <TD>Timer Current Values (TA)</TD>
    <TD>0 (00)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Counter Current Values (CTA)</TD>
    <TD>512 (01000)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Global Inputs (VGX)</TD>
    <TD>16384 (040000)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Global Outputs (VGY)</TD>
    <TD>16512 (040200)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Inputs (VX)</TD>
    <TD>16640 (040400)</TD>
    <TD>4</TD>
  </TR>
  <TR>
    <TD>Outputs (VY)</TD>
    <TD>16704 (040500)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Control Relays (VC)</TD>
    <TD>16768 (040600)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Stage Status Bits (VS)</TD>
    <TD>16896 (041000)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Timer Contacts (VT)</TD>
    <TD>16960 (041100)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Counter Contacts (VCT)</TD>
    <TD>16992 (041140)</TD>
    <TD>3, 6, 16</TD>
  </TR>
  <TR>
    <TD>Special Relays (VSP)</TD>
    <TD>17024 (041200)</TD>
    <TD>4</TD>
  </TR>
 </TBODY>
</TABLE>

<P>
Other PLC manufactures will use different Modbus addresses.
<P>
Note that 16-bit Modbus addresses are commonly specified with an offset of 400001 (or 300001).
This offset is not used by the modbusTCP driver, it uses only the 16-bit address, not the offset.
<P>
<H3>Modbus data length limitations</H3>
Modbus read operations are limited to transferring 125 16-bit words or 2000 bits.
Modbus write operations are limited to transferring 123 16-bit words or 1968 bits.
<H3>More information on Modbus</H3>
<P> 
For more information about the Modbus protocol, the official Modbus specification can be found
<A href="http://www.modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf">on the Web</A>
or in the modbusTCP 
<A href="Modbus_Application_Protocol_V1_1b.pdf">documentation directory.</A>

<P>
The official specification for Modbus over TCP/IP can be found 
<A href="http://www.modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf">on the Web</A>
or in the modbusTCP 
<A href="Modbus_Messaging_Implementation_Guide_V1_0b.pdf">documentation directory.</A>

<P>
<H2><CENTER><A NAME="Driver architecture">
                     Driver architecture</A></H2></CENTER>

The <b>modbusTCP</b> module consists of an EPICS asyn port driver which functions as a Modbus client.
The modbusTCP port driver communicates with a Modbus server using the standard asyn TCP/IP port driver (drvAsynIPPort).
The modbusTCP port driver communicates with EPICS records using the standard asyn interfaces 
(asynUInt32Digital, asynInt32, etc.) and standard EPICS device support.  Because modbusTCP makes extensive
use of these existing asyn facilities, the amount of code in modbusTCP is quite small (less than 2,000 lines of
code).
<P>
<B>CAUTION:</B> modbusTCP can provide access to all of the I/O and memory of the PLC.
In fact, it is not
even necessary to run a ladder logic program in the PLC at all.  The PLC can be used as 
a "dumb" I/O subsystem, with all of the logic residing in the EPICS IOC.  However,
if a ladder logic program <i>is</i> being run in the PLC then the EPICS access with modbusTCP
must be designed carefully.  For example, the EPICS IOC might be allowed to <i>read</i> any of the 
PLC I/O points (X inputs, Y outputs, etc.), but <i>writes</i> could be restricted to a small
range of Control Registers, (e.g. C200-C240).  The ladder logic would monitor these
control registers, considering them to be "requests" from EPICS that should be acted
upon only if it is safe to do so.

<P>
Each modbusTCP port driver is assigned a single Modbus function code and a single contiguous range of 
Modbus memory, up to 2000 bits or 125 words.  One typically creates several modbusTCP port drivers
for a single PLC, each driver reading or writing a different set of discrete inputs, coils, 
input registers or holding registers.  For example, one might create one port driver to read 
discrete inputs X0-X37, a second to read control registers C0-C400, and a third to write control 
registers C300-C400.
<P>
The behavior of the port driver differs for
read function codes (1, 2, 3, 4) and write function codes (5, 6, 15, 16).
<P>
<H3>Modbus read functions</H3>
For read function codes the driver spawns a poller thread.  The poller thread reads the entire 
block of Modbus memory assigned to this port in a single Modbus transaction.  The values are
stored in a buffer in the driver.  The delay between
polls is set when the port driver is created, and can be changed later at run-time.  The
values are read using the standard asyn interfaces (asynUInt32Digital, asynInt32,
etc.)  The values that are read are the last stored values from the poller thread.  This means
that EPICS read operations are <i>synchronous</i>, i.e. they do not block because no Modbus I/O
is required.  
<P>
For read functions it is possible to set the EPICS records to "I/O Intr" scanning.
If this is done then the port driver will call back device support whenever there is new data
for that input.  This improves efficiency, because such records only process when needed, they
do not need to be periodically scanned.

<P>
<H3>Modbus write functions</H3>
For write function codes the driver does not create a poller thread.  Rather the driver does the
Modbus I/O in response to the write operations on the standard asyn interfaces.  This means that
EPICS write operations are <i>asynchronous</i>, i.e. they do block because Modbus I/O is required.
When the modbusTCP driver is created it tells asynManager that it can block, and asynManager
creates a separate thread that executes the write operations.
<P>
Word write operations using the asynUInt32Digital interface (with a mask parameter that is not 0x0 or
0xFFFF) are done using read/modify/write operations.  This allows multiple Modbus clients to
write and read single words in the same block of Modbus memory.  
However, it <i>does not</i> guarantee correct operation
if multiple Modbus clients (or the PLC itself) can modify bits within a single word.
This is because the
Modbus server is not doing the I/O as an atomic operation.
<P>
For write operations it is possible to specify that a single read operation should be done when
the port driver is created.  This can be used so that EPICS obtains the current value of an output
device when the IOC is initialized.  

<P>
<H2><CENTER><A NAME="Creating a modbusTCP port driver">
                     Creating a modbusTCP port driver</A></H2></CENTER>

Before a modbusTCP port driver can be created, it is necessary to first create an asyn TCP/IP
port driver to communicate with port 502 on the Modbus server on the Ethernet.  This is done
using the standard asyn command:
<pre>
drvAsynIPPortConfigure(portName, hostInfo, priority, noAutoConnect, noProcessEos)
</pre>
Documentation on this command can be found in the 
<A HREF=http://www.aps.anl.gov/epics/modules/soft/asyn/R4-7/asynDriver.html#drvAsynIPPort>
asynDriver documentation</A>.

<P>The following example creates an asyn IP port driver called "Koyo1" on port 502 at
IP address 164.54.160.158.  The default priority is used and the noAutoConnect flag is set
to 1 so that the modbusTCP driver, rather than asynManager, will handle connection management.
The noProcessEos flag is set to 1 because Modbus data is binary, not ASCII.
<pre>
drvAsynIPPortConfigure("Koyo1","164.54.160.158:502",0,1,1)
</pre>

<P>
Once the asyn IP port is created, a modbusTCP port is created with the following command:
<pre>
drvModbusTCPAsynConfigure(portName, 
                          tcpPortName, 
                          modbusFunction, 
                          modbusStartAddress, 
                          modbusLength,
                          dataType,
                          pollMsec, 
                          plcType);
</pre>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>drvModbusTCPAsynConfigure command</TH>
  </TR>
  <TR>
    <TH>Parameter</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>portName</TD>
    <TD>string</TD>
    <TD>Name of the modbusTCP port to be created.</TD>
  </TR>
  <TR>
    <TD>tcpPortName</TD>
    <TD>string</TD>
    <TD>Name of the asyn IP port previously created with drvAsynIPPortConfigure.</TD>
  </TR>
  <TR>
    <TD>modbusFunction</TD>
    <TD>int</TD>
    <TD>Modbus function code (1,2,3,4,5,6,15, or 16).</TD>
  </TR>
  <TR>
    <TD>modbusStartAddress</TD>
    <TD>int</TD>
    <TD>Start address for the Modbus data segment to be accessed.<BR>
       (0-65535 decimal, 0-0177777 octal).</TD>
  </TR>
 <TR>
    <TD>modbusLength</TD>
    <TD>int</TD>
    <TD>The length of the Modbus data segment to be accessed.<BR>
        This is specified in bits for Modbus functions 1, 2, 5 and 15.<BR>
        It is specified in 16-bit words for Modbus functions 3, 4, 6 and 16.<BR>
        Length limit is 2000 for functions 1 and 2, 1968 for functions 5 and 15,<BR>
        125 for functions 3 and 4, and 123 for functions 6 and 16. </TD>
  </TR>
 <TR>
    <TD>modbusDataType</TD>
    <TD>int</TD>
    <TD>Modbus data type:<BR>
        0 = binary, twos-complement format<BR>
        1 = binary, sign and magnitude format<BR>
        2 = BCD, unsigned<BR>
        3 = BCD, signed</TD>
  </TR>
<TR>
    <TD>pollMsec</TD>
    <TD>int</TD>
    <TD>Polling delay time in msec for the polling thread for read functions.<BR>
        For write functions, a non-zero value means that the Modbus data should<BR>
        be read once when the port driver is first created.</TD>
  </TR>
  <TR>
    <TD>plcType</TD>
    <TD>string</TD>
    <TD>Type of PLC (e.g. Koyo, Modicon, etc.).  <BR>
        This parameter is currently used only to print information in asynReport.<BR>
        In the future it could be used to modify the driver behavior for a specific PLC.</TD>
  </TR>
 </TBODY>
</TABLE>
<P>
It can be convenient to specify the modbusStartAddress and modbusLength in octal, rather than
decimal. because this is the convention on most PLCs.  
In the iocsh and vxWorks shells this is done by using a leading 0 on the number, i.e.
040400 is an octal number.
<P>
The modbusDataType is used to tell the driver the format of the Modbus data.  The driver
uses this information to convert the number between EPICS and Modbus.  Data is transferred
to and from EPICS as epicsUInt32, epicsInt32, and epicsFloat64 numbers.  (Note that if
it is desired to transmit BCD numbers untranslated to EPICS over the asynInt32 interface, 
then data type 0 should be used, because no translation is done in this case.)
<UL>
  <LI>Type 0 is used for binary numbers in twos-complement format.  The data
      can either be signed or unsigned.
  <LI>Type 1 is used for binary numbers in sign and magnitude format.  
      In this format bit 15 is the sign bit, and bits 0-14 are the absolute value of the 
      magnitude of the number.  
      This is one of the formats used by Koyo PLCs for numbers such as ADC conversions.
  <LI>Type 2 is used for unsigned BCD (binary coded decimal) numbers.  
      In this format a 16-bit number consists of 4 4-bit nibbles, each of which encodes
      a decimal number from 0-9. A BCD number can thus store numbers from 0 to 9999.
      Many PLCs store some numbers in BCD format.
  <LI>Type 3 is used for signed BCD (binary coded decimal) numbers.  
      In this format a 16-bit number consists of 3 4-bit nibbles, and one 3-bit nibble. 
      Bit 15 is a sign bit.  Signed BCD numbers can hold values
      from -7999 to +7999.
      This is one of the formats used by Koyo PLCs for numbers such as ADC conversions.
</UL>
Ohter data types can be added in the future as needed.

<P>
<H2><CENTER><A NAME="EPICS device support">
                     EPICS device support</A></H2></CENTER>

modbusTCP implements the following standard asyn interfaces:
<UL>
  <LI>asynUInt32Digital
  <LI>asynInt32
  <LI>asynInt32Array
  <LI>asynFloat64
  <LI>asynCommon
  <LI>asynDrvUser
</UL>

Because it implements these standard interfaces, EPICS device support is done entirely
with the generic EPICS device support provided with asyn itself.  There is no special
device support provided as part of modbusTCP.
<P>
It is necessary to use asyn R4-8 or later, because some minor enhancements were made
to asyn to support the features required by modbusTCP.
<P>

The following tables document the asyn interfaces used by the EPICS device support.
<P>
The <b>drvUser</b> parameter is used by the driver to determine what command is being sent
from device support.  The default is MODBUS_DATA, which is thus optional in the
link specification in device support.
<P>The <b>offset</b> parameter is used to specify the location of the data for a record
relative to the starting Modbus address for that driver.  This <b>offset</b> is specified in
bits for drivers using Modbus functions 1, 2, 5, and 15 
that control discrete inputs or coils.  
<P>
For example, if the Modbus function is 2 and the Modbus starting address is 04000, 
then <b>offset=2</b> refers to address 04002.  For a Koyo PLC the X inputs are at this Modbus
starting address for Modbus function 2, so <b>offset=2</b> is input X2.  
<P>
The <b>offset</b> is specified in
words for drivers using Modbus functions 3, 4, 6 and 16 that control input registers or holding
registers.  For example, if the Modbus function is set to 6 and the Modbus address is 
040600 then <b>offset=2</b> refers to address 040602.   For a Koyo PLC the C control relays
are accessed as 16-bit words at this Modbus starting address for Modbus function 6.
<b>offset=2</b> will thus write to the third 16 bit-word, which are coils C40-C57.

<H3>asynUInt32Digital</H3>
asynUInt32Digital device support is selected with 
<pre>
field(DTYP,"asynUInt32Digital")
field(INP,"@asynMask(portName,offset,mask,timeout)drvUser")</pre>
</pre>

<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynUInt32Digital Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bi, mbbi, mbbiDirect, longin</TD>
    <TD>value = (Modbus data & mask)</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bi, mbbi, mbbiDirect, longin</TD>
    <TD>value = (Modbus data & mask)</TD>
  </TR>
  <TR>
    <TD>5</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bo, mbbo, mbboDirect, longout</TD>
    <TD>Modbus write (value & mask)</TD>
  </TR>
  <TR>
    <TD>6</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>bo, mbbo, mbboDirect, longout</TD>
    <TD>If mask==0 or mask==0xFFFF does Modbus write (value)<BR>
        Else does read/modify/write,<BR>
        sets bits that are set in value and set in mask,<BR>
        clears bits that are clear in value and set in mask</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>ENABLE_HISTOGRAM</TD>
    <TD>bi, mbbi, mbbiDirect, longin</TD>
    <TD>Returns 0/1 if I/O time histogramming is disabled/enabled in driver<BR>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>ENABLE_HISTOGRAM</TD>
    <TD>bo, mbbo, mbboDirect, longout</TD>
    <TD>If value = 0/1 then disable/enable I/O time histogramming in driver<BR>
  </TR>
 </TBODY>
</TABLE>
  

<H3>asynInt32</H3>
asynInt32 device support is selected with 
<pre>
field(DTYP,"asynInt32")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
</pre>
or
<pre>
field(INP,"@asynMask(portName,offset,nbits,timeout)drvUser")</pre>
</pre>
The asynMask syntax is used for analog I/O devices, in order to specify the
number of bits in the device.  This is required for Modbus because the driver
only knows that it is returning a 16-bit register, but not the actual number of
bits in the device, and hence cannot return meaningful data with asynInt32->getBounds().
<P>
nbits>0 for a unipolar device.  For example, nbits=12 means unipolar 12-bit device,
with a range of 0 to 4095.
nbits<0 for a bipolar device.  For example, nbits=-12 means bipolar 12-bit device, 
with a range of -2048 to 2047)
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynInt32 Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>value = (epicsInt32)Modbus data</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>value = (epicsInt32)Modbus data</TD>
  </TR>
  <TR>
    <TD>5</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao, mbbo, longout</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>6</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao, mbbo, longout</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>READ_OK</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of succesful read operations on this asyn port</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>WRITE_OK</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of succesful write operations on this asyn port</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>IO_ERRORS</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of I/O errors on this asyn port</TD>
  </TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>LAST_IO_TIME</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns number of milliseconds for last I/O operation</TD>
  </TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>MAX_IO_TIME</TD>
    <TD>ai, mbbi, longin</TD>
    <TD>Returns maximum number of milliseconds for I/O operations</TD>
  </TR>
 </TBODY>
</TABLE>
  
<H3>asynFloat64</H3>
asynFloat64 device support is selected with 
<pre>
field(DTYP,"asynFloat64")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynFloat64 Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai</TD>
    <TD>value = (epicsFloat64)Modbus data</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ai</TD>
    <TD>value = (epicsFloat64)Modbus data</TD>
  </TR>
  <TR>
    <TD>5</TD>
    <TD>Bit</TD>
    <TD>Single bit</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>6</TD>
    <TD>16-bit word</TD>
    <TD>16-bit word</TD>
    <TD>MODBUS_DATA</TD>
    <TD>ao</TD>
    <TD>Modbus write (epicsInt16)value</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>POLL_DELAY</TD>
    <TD>ai, ao</TD>
    <TD>Read or write the delay time in seconds between polls for the read poller thread.</TD>
  </TR>
 </TBODY>
</TABLE>
  
<H3>asynInt32Array</H3>
asynInt32Array device support is selected with 
<pre>
field(DTYP,"asynInt32ArrayWfIn")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
</pre>
or
<pre>
field(DTYP,"asynInt32ArrayWfOut")
field(INP,"@asyn(portName,offset,timeout)drvUser")</pre>
</pre>
asynInt32Array device support is used to read or write arrays of up to 2000 coil values
or up to 125 16-bit registers.  It is also used to read the histogram array of I/O times
when histogramming is enabled.
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=6, align=center>asynInt32Array Device Support</TH>
  </TR>
  <TR>
    <TH>Modbus function</TH>
    <TH>Offset type</TH>
    <TH>Data type</TH>
    <TH>drvUser</TH>
    <TH>Records supported</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>1, 2</TD>
    <TD>NA</TD>
    <TD>Array of bits</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (input)</TD>
    <TD>value = (epicsInt32)Modbus data[]</TD>
  </TR>
  <TR>
    <TD>3, 4</TD>
    <TD>NA</TD>
    <TD>Array of 16-bit words</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (input)</TD>
    <TD>value = (epicsInt32)Modbus data[]</TD>
  </TR>
  <TR>
    <TD>15</TD>
    <TD>NA</TD>
    <TD>Array of bits</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (output)</TD>
    <TD>Modbus write (epicsInt16)value[]</TD>
  </TR>
  <TR>
    <TD>16</TD>
    <TD>NA</TD>
    <TD>Array of 16-bit words</TD>
    <TD>MODBUS_DATA</TD>
    <TD>waveform (output)</TD>
    <TD>Modbus write (epicsInt16)value[]</TD>
  </TR>
  <TR>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>NA</TD>
    <TD>READ_HISTOGRAM</TD>
    <TD>waveform (input)</TD>
    <TD>Returns an histogram array of the I/O times in milliseconds since
        histogramming was last enabled.</TD>
  </TR>
 </TBODY>
</TABLE>
<P>
<H3>Template files</H3>
<P> 
modbusTCP provides example template files in the modtcpApp/Db directory.  
These include:
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=3, align=center>Template Files</TH>
  </TR>
  <TR>
    <TH>Files</TH>
    <TH>Description</TH>
    <TH>Macro arguments</TH>
  </TR>
  <TR>
  <TR>
    <TD>bi_bit.template</TD>
    <TD>asynUInt32Digital support for bi record with discrete inputs or coils.</TD>
    <TD>P, R, PORT, OFFSET, ZNAM, ONAM, ZSV, OSV, SCAN</TD>
  </TR>
  <TR>
    <TD>bi_word.template</TD>
    <TD>asynUInt32Digital support for bi record with register inputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK, ZNAM, ONAM, ZSV, OSV, SCAN</TD>
  </TR>
  <TR>
    <TD>mbbiDirect.template</TD>
    <TD>asynUInt32Digital support for mbbiDirect record with register inputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK, SCAN</TD>
  </TR>
  <TR>
    <TD>longin.template</TD>
    <TD>asynUInt32Digital support for longin record with register inputs. Mask=0xFFFF.</TD>
    <TD>P, R, PORT, OFFSET, SCAN</TD>
  </TR>
  <TR>
    <TD>intarray_in.template</TD>
    <TD>asynInt32Array support for waveform record with discrete, coil, or register inputs.</TD>
    <TD>P, R, PORT, NELM, SCAN</TD>
  </TR>
  <TR>
    <TD>bo_bit.template</TD>
    <TD>asynUInt32Digital support for bo record with coil outputs.</TD>
    <TD>P, R, PORT, OFFSET, ZNAM, ONAM</TD>
  </TR>
  <TR>
    <TD>bo_word.template</TD>
    <TD>asynUInt32Digital support for bo record with register outputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK, ZNAM, ONAM</TD>
  </TR>
  <TR>
    <TD>mbboDirect.template</TD>
    <TD>asynUInt32Digital support for mbboDirect record with register outputs.</TD>
    <TD>P, R, PORT, OFFSET, MASK</TD>
  <TR>
    <TD>longout.template</TD>
    <TD>asynUInt32Digital support for longout record with register outputs. Mask=0xFFFF.</TD>
    <TD>P, R, PORT, OFFSET</TD>
  </TR>
  <TR>
    <TD>intarray_out.template</TD>
    <TD>asynInt32Array support for waveform record with discrete, coil, or register outputs.</TD>
    <TD>P, R, PORT, NELM</TD>
  </TR>
  </TR>
    <TD>ai.template</TD>
    <TD>asynInt32 support for ai record with LINEAR conversion</TD>
    <TD>P, R, PORT, OFFSET, BITS, EGUL, EGUF, PREC, SCAN</TD>
  </TR>
  <TR>
    <TD>ai_average.template</TD>
    <TD>asynInt32Average support for ai record with LINEAR conversion.  This support
        gets callbacks each time the poll thread reads the analog input, and averages
        readings until the record is processed.</TD>
    <TD>P, R, PORT, OFFSET, BITS, EGUL, EGUF, PREC, SCAN</TD>
  </TR>
  <TR>
    <TD>asynRecord.template</TD>
    <TD>Support for asyn record.  Useful for controlling trace printing, and for debugging.</TD>
    <TD>P, R, PORT, ADDR, TMOD, IFACE</TD>
  </TR>
  <TR>
    <TD>poll_delay.template</TD>
    <TD>Support for ao record to control the delay time for the poller thread.</TD>
    <TD>P, R, PORT</TD>
  </TR>
  <TR>
    <TD>statistics.template</TD>
    <TD>Support for bo, longin and waveform records to read I/O statistics for the port.
    <TD>P, R, PORT, SCAN</TD>
  </TR>
 </TBODY>
</TABLE>
<P>
The following table explains the macro parameters used in the preceeding table.
<P>
<TABLE style="TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 border=1>
  <TBODY>
  <TR>
    <TH colspan=2, align=center>Macro Parameters</TH>
  </TR>
  <TR>
    <TH>Macro</TH>
    <TH>Description</TH>
  </TR>
  <TR>
    <TD>P</TD>
    <TD>Prefix for record name.  Complete record name is $(P)$(R).</TD>
  </TR>
  <TR>
    <TD>R</TD>
    <TD>Record name.  Complete record name is $(P)$(R).</TD>
  </TR>
  <TR>
    <TD>PORT</TD>
    <TD>Port name for modbusTCP asyn port.</TD>
  </TR>
  <TR>
    <TD>OFFSET</TD>
    <TD>Offset for Modbus data relative to start address for this port.</TD>
  </TR>
  <TR>
    <TD>MASK</TD>
    <TD>Bit mask used to select data for this record.</TD>
  </TR>
  <TR>
    <TD>ZNAM</TD>
    <TD>String for 0 value for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>ZSV</TD>
    <TD>0 severity for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>OSV</TD>
    <TD>1 severity for bi/bo records.</TD>
  </TR>
  <TR>
    <TD>BITS</TD>
    <TD>Number of bits for analog I/O devices. >0=unipolar, <0=bipolar.</TD>
  </TR>
  <TR>
    <TD>EGUL</TD>
    <TD>Engineering value for lower limit of analog device.</TD>
  </TR>
  <TR>
    <TD>EGUF</TD>
    <TD>Engineering value for upper limit of analog device.</TD>
  </TR>
  <TR>
    <TD>PREC</TD>
    <TD>Number of digits of precision for ai/ao records.</TD>
  </TR>
  <TR>
    <TD>NELM</TD>
    <TD>Number of elements in waveform records.</TD>
  </TR>
  <TR>
    <TD>ADDR</TD>
    <TD>Address for asyn record, same as OFFSET above.</TD>
  </TR>
  <TR>
    <TD>TMOD</TD>
    <TD>Transfer mode for asyn record.</TD>
  </TR>
  <TR>
    <TD>IFACE</TD>
    <TD>asyn interface for asyn record.</TD>
  </TR>
  <TR>
    <TD>SCAN</TD>
    <TD>Scan rate for record (e.g. "1 second", "I/O Intr", etc.).</TD>
  </TR>
 </TBODY>
</TABLE>

<H2><CENTER><A NAME="Example Applications">
                     Example Applications</A></H2></CENTER>
<P>
modbusTCP builds an example application called modbusTCPApp.  This application can be run
to control any number of Modbus PLCs.
<P>
In the iocBoot/iocTest directory there are several startup scripts for EPICS IOCs.  These
are designed to test most of the features of the modbusTCP driver on Koyo PLCs, such as the
DL series from Automation Direct.
<P>
<UL>
  <LI>Koyo1.cmd creates modbusTCP port drivers to read the X input registers,
      write to the Y output registers, and read and write from the C control registers.
      Each of these sets of inputs is accessed both as coils and as registers (V memory).
      bi/bo, mbbiDirect/mbboDirect, and waveform records are loaded to read and write
      using these drivers.
  <LI>Koyo2.cmd creates modbusTCP port drivers to read the X input registers,
      write to the Y output registers, and read and write from the C control registers.
      Only coil access is used.  This example also reads a 4-channel 13-bit bipolar A/D
      converter.  This has been tested using both signed-BCD and sign plus magnitude binary
      formats.  Note that a ladder logic program must be running that does the appropriate
      conversion of the A/D values into V memory.
  <LI>st.cmd is a simple example startup script to be run on non-vxWorks IOCs.  It just loads
      Koyo1.cmd and Koyo2.cmd.  It is invoked using a command like:
      <pre>
      ../../bin/linux-x86/modbusTCPApp st.cmd
      </pre>
  <LI>st.cmd.vxWorks is a simple example startup script to be run on vxWorks IOCs.  It just loads
      Koyo1.cmd and Koyo2.cmd.
</UL>
<P>
The following is the beginning of Koyo1.cmd.
<pre>
# Koyo1.cmd
< envPaths

dbLoadDatabase("../../dbd/modbusTCP.dbd")
modbusTCP_registerRecordDeviceDriver(pdbbase)

#drvAsynIPPortConfigure(const char *portName, const char *hostInfo,
#                           unsigned int priority, int noAutoConnect,
#                           int noProcessEos);
drvAsynIPPortConfigure("Koyo1","164.54.160.158:502",0,1,1)
#drvAsynIPPortConfigure("Koyo1","164.54.160.201:502",0,0,1)


# NOTE: We use octal numbers for the start address and length (leading zeros)
#       to be consistent with the PLC nomenclature.  This is optional, decimal
#       numbers (no leading zero) or hex numbers can also be used.

# The DL205 has bit access to the Xn inputs at Modbus offset 4000 (octal)
# Read 32 bits (X0-X37).  Function code=2.
drvModbusTCPAsynConfigure("K1_Xn_Bit",      "Koyo1", 2,  04000, 040,    0,  100, "Koyo")

# The DL205 has word access to the Xn inputs at Modbus offset 40400 (octal)
# Read 8 words (128 bits).  Function code=3.
drvModbusTCPAsynConfigure("K1_Xn_Word",     "Koyo1", 3, 040400, 010,    0,  100, "Koyo")

# The DL205 has bit access to the Yn outputs at Modbus offset 4000 (octal)
# Read 32 bits (Y0-Y37).  Function code=1.
drvModbusTCPAsynConfigure("K1_Yn_In_Bit",   "Koyo1", 1,  04000, 040,    0,  100, "Koyo")

# The DL205 has bit access to the Yn outputs at Modbus offset 4000 (octal)
# Write 32 bits (Y0-Y37).  Function code=5.
drvModbusTCPAsynConfigure("K1_Yn_Out_Bit",  "Koyo1", 5,  04000, 040,    0,  1, "Koyo")

# The DL205 has word access to the Yn outputs at Modbus offset 40500 (octal)
# Read 8 words (128 bits).  Function code=3.
drvModbusTCPAsynConfigure("K1_Yn_In_Word",  "Koyo1", 3, 040500, 010,    0,  100, "Koyo")

# Write 8 words (128 bits).  Function code=6.
drvModbusTCPAsynConfigure("K1_Yn_Out_Word", "Koyo1", 6, 040500, 010,    0,  100, "Koyo")

# The DL205 has bit access to the Cn bits at Modbus offset 6000 (octal)
# Access 256 bits (C0-C377) as inputs.  Function code=1.
drvModbusTCPAsynConfigure("K1_Cn_In_Bit",   "Koyo1", 1,  06000, 0400,   0,  100, "Koyo")

# Access the same 256 bits (C0-C377) as outputs.  Function code=5.
drvModbusTCPAsynConfigure("K1_Cn_Out_Bit",  "Koyo1", 5,  06000, 0400,   0,  1,  "Koyo")

# Access the same 256 bits (C0-C377) as array outputs.  Function code=15.
drvModbusTCPAsynConfigure("K1_Cn_Out_Bit_Array",  "Koyo1", 15,  06000, 0400,   0,   1, "Koyo")

# The DL205 has word access to the Cn bits at Modbus offset 40600 (octal)
# We use the first 16 words (C0-C377) as inputs (256 bits).  Function code=3.
drvModbusTCPAsynConfigure("K1_Cn_In_Word",  "Koyo1", 3, 040600, 020,    0,  100, "Koyo")

# We access the same 16 words (C0-C377) as outputs (256 bits). Function code=6.
drvModbusTCPAsynConfigure("K1_Cn_Out_Word", "Koyo1", 6, 040600, 020,    0,  1,  "Koyo")

# We access the same 16 words (C0-C377) as array outputs (256 bits). Function code=16.
drvModbusTCPAsynConfigure("K1_Cn_Out_Word_Array", "Koyo1", 16, 040600, 020,    0,   1, "Koyo")
</pre>

Note that this example is designed for testing and demonstration purposes, not as a realistic
example of how ModbusTCP would normally be used.  For example, it loads 
6 drivers to access the C control relays using function codes 1 (read coils), 3 (read holding
registers), 5 (write single coil), 6 (write single holding register), 15 (write multiple coils),
and 16 (write multiple holding registers).  This allows for testing of all function codes
and record types, including waveforms.  In practice one would normally only load at most 2
drivers for the C control relays, for example function code 1 (read coils), and function
code 5 (write single coil).

<H2><CENTER><A NAME="medm screens">
                     medm screens</A></H2></CENTER>
<P>
modbusTCP provides example medm .adl files in the modtcpApp/op/adl directory.  
The following are screen shots of these screens from an IOC controlling a
Koyo DL205 PLC.

Koyo1.adl.  Top level medm screen for the Koyo1 example application.

Koyo_8inputs.adl.  Inputs X0-X7 read as discrete inputs (function code 1).

Koyo_8outputs.adl.  Outputs Y0-Y7 written using register access (function code 6).

ModbusTCPArray.adl.  Inputs C0-C377 read using a waveform record and
coil access (function code 1).

ModbusTCPArray.adl.  Inputs C0-C377 read using a waveform record and register access (function
code 3).

ModbusTCPStatistics.adl.  I/O statistics for the Modbus driver that is reading inputs
X0-X37 using register access (function code 3).  The histogram is the number of event
versus TCP/IP write/read cycle time in msec.

Koyo2.adl.  Top level medm screen for the Koyo2 example application.

Koyo_4ADC.adl.  4 ADC inputs from a 13-bit bipolar ADC.


<H2><CENTER><A NAME="Debug tracing">
                     Debug tracing</A></H2></CENTER>
                     
One can obtain diagnostic output for a modbusTCP port driver using the "dbior" or "asynPrint" commands
at the iocsh or vxWorks shell.  For example
<pre>
asynReport
</pre>
will print a brief report for all asyn drivers, including the drvAsynIPPort driver that modbusTCP
drivers are connected to, and for all modbusTCP port drivers.  To obtain more
detailed information, one can request information for a specific modbusTCP port driver, and
output level >0 as follows:
<pre>
asynReport "K2_Xn_Bit", 5
</pre>
<P>
To obtain run-time debugging output for a driver use the asynSetTraceMask and asynSetTraceIOMask 
commands.  For example the following commands will show
all I/O to and from the PLC from the underlying drvAsynIPPort driver:
<pre>
(Get command and output here)
</pre>

The following command shows the I/O from a specific modbusTCP port driver:
<pre>
(Get command and output here)
</pre>

One can also load an EPICS asyn record on a modbusTCP port, and then use EPICS channel access
to turn debugging output on and off.  The following medm screen shows how to turn on I/O tracing
using this method.

The asyn record can also be used to perform actual I/O to the PLC.  For example the following
screen shots shows the asyn record being used to control output Y1 on a PLC.  Note that the ADDR
field is set to 1 (to select Y1) and the data set to 1 (to turn on the output).  Each time the
asyn record is processed the value will be sent to the PLC.
<P>
(medm screen shots)

<H2><CENTER><A NAME="Differences from Triumf modtcp and plctcp package">
                     Differences from Triumf modtcp and plctcp package</A></H2></CENTER>
                     
modtcp supports only Modbus functions 3 (read holding register) and 6 (write holding register).  modbusTCP supports most Modbus function codes,
including 1, 2 and 5 for reading and writing coils (single bits) and 15 and 16 for writing multiple bits and multiple registers. <BR>

Supports pseudo-interrupt mode on inputs.  The poller thread calls device support when there is a new value, so the EPICS records can have SCAN=I/O Intr
and do not need to periodically read the inputs. <BR>

Array operations on reads and writes using waveform records <BR>

Uses asyn for underlying TCP/IP connections.  Reduces amount of code, and has good debugging and connection management <BR>

Uses standard asyn interfaces and asyn device support.  Reduces code. <BR>

Provides EPICS PVs for PLC status and statistics. <BR>

Minus <BR>
No watchdog yet. <BR>

No Siemens PLC support.  It should be a separate driver, using drvModbusTCPAsyn.c as a starting point.  Cleaner to keep them separate. <BR>

One thread per asyn port, which is a group of Modbus registers or coils.  This is more threads than modtcp, which had only 1 thread per PLC. There is an
advantage, each can poll at a different rate, can have different Modbus function code, and a different data type. <BR>


<H2><CENTER><A NAME="Known problems">
                     Known problems</A></H2></CENTER>
                     
Fix connection management problem in asyn with autoConnect=1.  Must use noAutoConnect=1 for
now. <BR>

Change API for callbacks to add status, report communication errors to EPICS <BR>

Add mbbiDirect, mbboDirect records, add to .adl files <BR>


<H2><CENTER><A NAME="Offsets for Koyo PLCs">
                     Offsets for Koyo PLCs</A></H2></CENTER>

Take from Koyo manual <BR>
 


<H3><SPAN style="FONT-WEIGHT: bold"><A 
name=Functionality></A>Functionality:</SPAN></H3>
<UL>
  <LI>modtcp supports communications to more than one PLC out of &nbsp;one 
  IOC.<BR>
  <LI>reading data from PLC:<BR>A background task (one per PLC) &nbsp;reads 
  groups of data from the PLC into an&nbsp; IOC memory buffer. Data are read in 
  groups of <SPAN style="FONT-WEIGHT: bold; COLOR: rgb(255,0,0)">up to 
  125</SPAN> registers.&nbsp; 
  <LI>writing data to PLC:<BR>A background tasks (one per PLC) writes changed 
  data from the IOC memory buffer to the PLC. Data transfer is not optimized, 
  data are written one register per ethernet message. 
  <LI>an [optional] watchdog task (one per PLC) can be used to set INVALID 
  alarms on records, if the IOC &lt;--&gt; PLC communication is interrupted. 
<BR>
  <LI><SPAN style="COLOR: rgb(153,153,153)">the driver recovers from Ethernet 
  interruptions or disconnects</SPAN> *** change in Version of 
  8-Feb-2004:<BR>see section "Connection Failures" below<BR>
  <LI>EPICS record support:<BR>
  <OL>
    <LI>bi, bo 
    <LI>mbbi, mbbo 
    <LI>mbbiDirect, mbboDirect 
    <LI>ai, ao<BR>- for ai and ao records, both unipolar and bipolar (2's 
    complement) data are supported<BR></LI></OL>
  <LI>EPICS addressing: &nbsp; #Cx Sy @n [p] &nbsp;where<BR>
  <OL>
    <LI>x &nbsp; is the PLC register address relative to the output register 
    base, i.e. C1 &lt;==&gt; 400001 
    <LI>y &nbsp; is the bit number (0..15) in the PLC register. This is used 
    for&nbsp; bi and bo records only. <BR>
    <LI>n &nbsp; is the PLC index (0 for the first PLC) 
    <LI>p &nbsp; is an optional bit-range identifier for analog records. p is 
    specified in hex notation of the format [-]&lt;range&gt;, where the minus 
    sign indicates a bipolar signal<BR>Default bit-range is 12 bits, 
    unipolar<BR>Examples for the p parameter:<BR>- for a 16 bit unipolar signal 
    set p to 0xffff<BR>- for an 11 bit unipolar signal set p to 0x7ff<BR>- for a 
    16 bit bipolar (2's complement) signal, set p to -0x7fff<BR>- for a 12 bit 
    bipolar (2's complement) signal, set p to -0x7ff<BR>- for an 11 bit bipolar 
    (2's complement) signal, set p to -0x3ff<BR>For analog records with bipolar 
    signals set (EGUL, EGUF) to (0, engineering value at &lt;range&gt;) 
  </LI></OL></LI></UL><BR><A 
href="http://isacwserv.triumf.ca/epics/modtcp/TRIUMFmodtcp.html#TRIUMF_Device_and_Driver_Support_for">top</A><BR><BR><BR><BR><BR><BR>
<H3><SPAN style="FONT-WEIGHT: bold"><A name=Console_Interface></A>Interface 
Functions:</SPAN></H3>The following commands are implemented for use in IOC 
startup scripts and from the IOC consolse (you'll find probably a few more in 
the source code). The example of an IOC startup script shows the typical use of 
these functions. Please note in this example, that the polling of the PLC is 
slowed down by setting the global variable moddelay to 20<BR><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpDrvCreate</SPAN> <BR></H4>Defines a 
new PLC. The first call to this function creates PLC 0, the next PLC 1, 
...<BR><BR>
<TABLE style="WIDTH: 500px; TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 
border=1>
  <TBODY>
  <TR>
    <TH style="VERTICAL-ALIGN: top"><SPAN 
      style="FONT-STYLE: italic"></SPAN><BR></TH>
    <TH style="VERTICAL-ALIGN: top">Parameters:</TH>
    <TH style="VERTICAL-ALIGN: top">type<BR></TH></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">1<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC name<BR></TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">2<BR></TD>
    <TD style="VERTICAL-ALIGN: top">TCP/IP port<BR></TD>
    <TD style="VERTICAL-ALIGN: top">integer<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">3<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC IP address<BR></TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">4<BR></TD>
    <TD style="VERTICAL-ALIGN: top">length of&nbsp; memory buffer<BR></TD>
    <TD 
style="VERTICAL-ALIGN: top">integer<BR></TD></TR></TBODY></TABLE>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpDrvCreate("itwplc",502,"142.90.132.94",4096)</PRE><SPAN 
style="FONT-WEIGHT: bold"><BR><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpDrvReadGroup</SPAN> <BR></H4>Defines a 
"read group",&nbsp; i.e. a contiguous set of registers to be read from the 
PLC.<BR><BR>
<TABLE style="WIDTH: 500px; TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 
border=1>
  <TBODY>
  <TR>
    <TH style="VERTICAL-ALIGN: top"><SPAN 
      style="FONT-STYLE: italic"></SPAN><BR></TH>
    <TH style="VERTICAL-ALIGN: top">Parameters:</TH>
    <TH style="VERTICAL-ALIGN: top">type<BR></TH></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">1<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC name<BR></TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">2<BR></TD>
    <TD style="VERTICAL-ALIGN: top">start of read group in PLC (1 &lt;==&gt; 
      400001) <BR></TD>
    <TD style="VERTICAL-ALIGN: top">integer<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">3<BR></TD>
    <TD style="VERTICAL-ALIGN: top">length of read group <SPAN 
      style="FONT-WEIGHT: bold; COLOR: rgb(204,0,0)">(must be &lt;= 
      125)</SPAN><SPAN style="FONT-WEIGHT: bold; COLOR: rgb(204,0,0)"></SPAN> 
</TD>
    <TD style="VERTICAL-ALIGN: top">integer<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">4<BR></TD>
    <TD style="VERTICAL-ALIGN: top">offset into memory buffer for 
    storage<BR></TD>
    <TD style="VERTICAL-ALIGN: top">integer</TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">5<BR></TD>
    <TD style="VERTICAL-ALIGN: top">read-only-once flag (0 = read 
      continuously)<BR></TD>
    <TD 
style="VERTICAL-ALIGN: top">integer<BR></TD></TR></TBODY></TABLE>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpDrvReadGroup("itwplc",1001,23,1001,0)</PRE><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpDrvWriteGroup</SPAN> <BR></H4>Defines 
a "write group",&nbsp; i.e. a contiguous area of the memory buffer, which is 
monitored for changes. Changed values are written to the PLC.<BR><BR>
<TABLE style="WIDTH: 500px; TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 
border=1>
  <TBODY>
  <TR>
    <TH style="VERTICAL-ALIGN: top"><SPAN 
      style="FONT-STYLE: italic"></SPAN><BR></TH>
    <TH style="VERTICAL-ALIGN: top">Parameters:</TH>
    <TH style="VERTICAL-ALIGN: top">type<BR></TH></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">1<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC name<BR></TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">2<BR></TD>
    <TD style="VERTICAL-ALIGN: top">start of write group in PLC (1 &lt;==&gt; 
      400001) <BR></TD>
    <TD style="VERTICAL-ALIGN: top">integer<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">3<BR></TD>
    <TD style="VERTICAL-ALIGN: top">length of write group <SPAN 
      style="FONT-WEIGHT: bold; COLOR: rgb(204,0,0)">(must be &lt;= 125)</SPAN> 
    </TD>
    <TD style="VERTICAL-ALIGN: top">integer<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">4<BR></TD>
    <TD style="VERTICAL-ALIGN: top">offset into memory buffer (start of data 
      to write)<BR></TD>
    <TD 
style="VERTICAL-ALIGN: top">integer</TD></TR></TBODY></TABLE>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpDrvWriteGroup("itwplc",2001,23,2001)</PRE><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpWatchdog</SPAN> <BR></H4>Specifies a 
watchdog location in the PLC, where the value is changing with each PLC 
scan.<BR><BR>
<TABLE style="WIDTH: 500px; TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 
border=1>
  <TBODY>
  <TR>
    <TH style="VERTICAL-ALIGN: top"><SPAN 
      style="FONT-STYLE: italic"></SPAN><BR></TH>
    <TH style="VERTICAL-ALIGN: top">Parameters:</TH>
    <TH style="VERTICAL-ALIGN: top">type<BR></TH></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">1<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC name<BR></TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">2<BR></TD>
    <TD style="VERTICAL-ALIGN: top">watchdog address (1 &lt;==&gt; 400001) 
    <BR></TD>
    <TD 
style="VERTICAL-ALIGN: top">integer<BR></TD></TR></TBODY></TABLE>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpWatchdog("itwplc",3001)</PRE><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpKeepAlive</SPAN> <BR></H4>Specifies a 
location in the PLC, to which the driver writes a changed value every 5 
seconds<BR><BR>
<TABLE style="WIDTH: 500px; TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 
border=1>
  <TBODY>
  <TR>
    <TH style="VERTICAL-ALIGN: top"><SPAN 
      style="FONT-STYLE: italic"></SPAN><BR></TH>
    <TH style="VERTICAL-ALIGN: top">Parameters:</TH>
    <TH style="VERTICAL-ALIGN: top">type<BR></TH></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">1<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC name<BR></TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">2<BR></TD>
    <TD style="VERTICAL-ALIGN: top">"keep alive" address (1 &lt;==&gt; 400001) 
      <BR></TD>
    <TD 
style="VERTICAL-ALIGN: top">integer<BR></TD></TR></TBODY></TABLE>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpKeepAlive("itwplc",101)</PRE><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN><SPAN style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpInit</SPAN> <BR></H4>Initializes 
communication with all PLCs<BR>&nbsp;&nbsp;&nbsp; <BR>Example:&nbsp;&nbsp;&nbsp; 
<BR><PRE>modtcpInit</PRE><SPAN style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpAbort</SPAN><BR></H4>Aborts 
communication with all PLCs<BR>&nbsp;&nbsp;&nbsp; <BR>Example:&nbsp;&nbsp;&nbsp; 
<BR><PRE>modtcpAbort</PRE><SPAN style="FONT-WEIGHT: bold"><BR></SPAN><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpReport</SPAN><BR></H4>Reports 
information about all PLCs on the system. If an optional parameter &gt; 0 is 
given, the reported information is more detailed <BR>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpReport 1</PRE><SPAN style="FONT-WEIGHT: bold"><BR></SPAN><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN><SPAN style="FONT-WEIGHT: bold"><BR></SPAN>
<H4><SPAN style="FONT-WEIGHT: bold">modtcpSetAutoReconnect</SPAN> 
<BR></H4>Enables/disables the auto-reconnect function of the driver. Default is 
set by #define DEFAULT_RECONNECT in file drvModtcp.c.<BR>NOTE: this function has 
no effect, if there is no watchdog specified.<BR><BR>
<TABLE style="WIDTH: 500px; TEXT-ALIGN: left" cellSpacing=2 cellPadding=2 
border=1>
  <TBODY>
  <TR>
    <TH style="VERTICAL-ALIGN: top"><SPAN 
      style="FONT-STYLE: italic"></SPAN><BR></TH>
    <TH style="VERTICAL-ALIGN: top">Parameters:</TH>
    <TH style="VERTICAL-ALIGN: top">type<BR></TH></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">1<BR></TD>
    <TD style="VERTICAL-ALIGN: top">PLC name</TD>
    <TD style="VERTICAL-ALIGN: top">string<BR></TD></TR>
  <TR>
    <TD style="VERTICAL-ALIGN: top">2<BR></TD>
    <TD style="VERTICAL-ALIGN: top">1 (= yes)&nbsp; or 0 (= no)<BR></TD>
    <TD 
style="VERTICAL-ALIGN: top">integer<BR></TD></TR></TBODY></TABLE>&nbsp;&nbsp;&nbsp; 
<BR>Example:&nbsp;&nbsp;&nbsp; <BR><PRE>modtcpSetAutoReconnect("itwplc",1);</PRE><A 
href="http://isacwserv.triumf.ca/epics/modtcp/TRIUMFmodtcp.html#TRIUMF_Device_and_Driver_Support_for">top</A><BR><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN><SPAN 
style="FONT-WEIGHT: bold"><BR></SPAN><BR>
<H3><SPAN style="FONT-WEIGHT: bold"><A name=Connection_Failures></A>Connection 
Failures</SPAN></H3><SPAN style="FONT-WEIGHT: bold"></SPAN>Behaviour of the 
driver if the Ethernet is interrupted:<BR>
<OL>
  <LI>if no watchdog task is specified in startup script:<BR>In this case read 
  and write tasks block on their TCP/IP recv functions.<BR>Use commands from the 
  IOC consoles:<BR>
  <DIV style="MARGIN-LEFT: 40px">"modtcpAbort" &nbsp;&nbsp; (or 
  "modtcpAbortPLC(&lt;PLC index&gt;)", if the IOC drives more than one 
  PLC)&nbsp;&nbsp; to abort the read and write tasks<BR>"modtcpInit"&nbsp;&nbsp; 
  (or "modtcpInitPLC(&lt;PLC index&gt;)", to restart the&nbsp; read and write 
  tasks<BR></DIV></LI></OL>
<OL start=2>
  <LI>if watchdog task is specified in startup script:<BR>In this case, the read 
  and write tasks are aborted, when there is no communication for X 5-second 
  intervals. X is configurable&nbsp; (see Console Interface).<BR><BR>The 
  reconnect behaviour is determined by the directive<BR>#define 
  DEFAULT_RECONNECT in the source file drvModtcp.c. <BR>This compile-time value 
  can be overridden by a call to&nbsp; modtcpSetAutoReconnect(1) in the IOC 
  startup script. A value of 1 causes the driver to attempt reconnecting&nbsp; 
  every 20 seconds. <BR></LI></OL><A 
href="http://isacwserv.triumf.ca/epics/modtcp/TRIUMFmodtcp.html#TRIUMF_Device_and_Driver_Support_for">top</A>&nbsp; 
<BR><BR><BR><BR>
<H3><SPAN style="FONT-WEIGHT: bold"><A name=Limitations_></A>Limitations and 
Known Problems:</SPAN></H3>
<UL>
  <LI>tested on: 
  <UL>
    <LI>&nbsp;Motorola CPUs with 680x0 architecture 
    <LI>TRI-M MZ104+&nbsp;&nbsp; (PC104) boards with x86 architecture 
    <LI>GMS Mariner&nbsp; (Pentium) </LI></UL>
  <LI><SPAN style="COLOR: rgb(153,153,153)">-- obsolete -- For use with Momentum 
  series PLCs, a "keep alive" write to the PLC must be implemented, otherwise 
  the TCP/IP server in the PLC closes write connections after a short period of 
  inactivity. In a future release, this will be implemented at the driver level. 
  -- obsolete --</SPAN><BR>
  <LI>The communication background tasks do only register transfers between PLC 
  and the IOC memory buffer, i.e supported MODBUS functions are<BR>
  <UL>
    <LI>function 3 (READ OUTPUT REGISTERS), i.e.&nbsp; no reading of individual 
    bits (coils). 
    <LI>function 6 (PRESET SINGLE REGISTER),&nbsp; i.e. no writing of individual 
    bits (coils) </LI></UL></LI></UL>
<DIV style="MARGIN-LEFT: 40px">Note, however, that EPICS device support supports 
binary input and output records.</DIV>
<DIV style="MARGIN-LEFT: 40px"><BR></DIV>Known problems:<BR>&nbsp;&nbsp;&nbsp; - 
none, until you tell me<BR><BR><BR><A 
href="http://isacwserv.triumf.ca/epics/modtcp/TRIUMFmodtcp.html#TRIUMF_Device_and_Driver_Support_for">top</A><BR><BR><A 
href="http://isacwserv.triumf.ca/epics/modtcp"></A><BR></BODY></HTML>
